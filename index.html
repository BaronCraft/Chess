<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–∞—Ö–º–∞—Ç–Ω–∞—è –¥–æ—Å–∫–∞ —Å –∞–Ω–∞–ª–∏–∑–æ–º –æ—Ç Lichess</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50, #1a252f);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: #34495e;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
            align-items: flex-start;
            max-width: 1400px;
        }

        .board-section {
            background: #2c3e50;
            border-radius: 15px;
            padding: 20px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }

        .board-container {
            position: relative;
            width: 600px;
            height: 600px;
        }

        .chess-board {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 3px solid #b8860b;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #7b9f7b !important;
            box-shadow: inset 0 0 0 3px #ffd700;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 100, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
        }

        .square.valid-capture::after {
            content: '';
            position: absolute;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(139, 0, 0, 0.6);
            border-radius: 50%;
            pointer-events: none;
        }

        .square.last-move {
            background-color: rgba(255, 255, 0, 0.3) !important;
        }

        .piece {
            cursor: grab;
            user-select: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .piece:active {
            cursor: grabbing;
        }

        .coordinates {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            color: #ecf0f1;
            font-weight: bold;
            padding: 0 10px;
        }

        .files {
            display: flex;
            justify-content: space-around;
            margin-bottom: 5px;
            color: #ecf0f1;
            font-weight: bold;
        }

        .ranks {
            position: absolute;
            left: -25px;
            top: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            color: #ecf0f1;
            font-weight: bold;
        }

        .info-panel {
            background: #2c3e50;
            border-radius: 15px;
            padding: 25px;
            color: #ecf0f1;
            min-width: 350px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .position-input {
            margin-bottom: 25px;
        }

        .position-input h3 {
            margin-bottom: 10px;
            color: #f1c40f;
            border-bottom: 2px solid #f1c40f;
            padding-bottom: 5px;
        }

        .fen-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .fen-input input {
            flex: 1;
            padding: 10px;
            border: 2px solid #7f8c8d;
            border-radius: 8px;
            background: #34495e;
            color: white;
            font-family: monospace;
            font-size: 14px;
        }

        .fen-input input:focus {
            outline: none;
            border-color: #f1c40f;
        }

        .fen-input button {
            padding: 10px 20px;
            background: #f1c40f;
            border: none;
            border-radius: 8px;
            color: #2c3e50;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }

        .fen-input button:hover {
            background: #d4ac0d;
        }

        .evaluation {
            background: #1e2b38;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
        }

        .eval-bar-container {
            height: 30px;
            background: #34495e;
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
            position: relative;
            border: 2px solid #7f8c8d;
        }

        .eval-bar {
            height: 100%;
            width: 50%;
            background: linear-gradient(90deg, #27ae60, #f1c40f, #e74c3c);
            transition: width 0.3s ease;
        }

        .eval-value {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            font-family: monospace;
        }

        .eval-value.positive {
            color: #2ecc71;
        }

        .eval-value.negative {
            color: #e74c3c;
        }

        .moves-section {
            max-height: 300px;
            overflow-y: auto;
            background: #1e2b38;
            border-radius: 10px;
            padding: 15px;
        }

        .moves-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-family: monospace;
        }

        .move-item {
            background: #34495e;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .move-item:hover {
            background: #f1c40f;
            color: #2c3e50;
            transform: translateY(-2px);
        }

        .move-item.current {
            background: #f1c40f;
            color: #2c3e50;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .controls button {
            padding: 10px 15px;
            background: #7f8c8d;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 80px;
        }

        .controls button:hover {
            background: #95a5a6;
            transform: translateY(-2px);
        }

        .controls button.primary {
            background: #27ae60;
        }

        .controls button.primary:hover {
            background: #2ecc71;
        }

        .status {
            text-align: center;
            padding: 10px;
            background: #1e2b38;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: bold;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #f1c40f;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notation {
            font-size: 14px;
            color: #bdc3c7;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board-section">
            <div class="files">
                <span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span>
            </div>
            <div class="board-container">
                <div class="ranks">
                    <span>8</span><span>7</span><span>6</span><span>5</span><span>4</span><span>3</span><span>2</span><span>1</span>
                </div>
                <div class="chess-board" id="chessBoard"></div>
            </div>
            <div class="coordinates">
                <span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span><span>g</span><span>h</span>
            </div>
        </div>

        <div class="info-panel">
            <div class="position-input">
                <h3>üìå –ü–æ–∑–∏—Ü–∏—è (FEN)</h3>
                <div class="fen-input">
                    <input type="text" id="fenInput" value="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1">
                    <button onclick="updatePositionFromFEN()">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
            </div>

            <div class="evaluation">
                <h3>üîç –û—Ü–µ–Ω–∫–∞ Lichess Cloud</h3>
                <div class="eval-bar-container">
                    <div class="eval-bar" id="evalBar" style="width: 50%"></div>
                </div>
                <div class="eval-value" id="evalValue">0.00</div>
                <div id="evalDepth" style="text-align: center; color: #7f8c8d; margin-top: 5px;"></div>
            </div>

            <div class="controls">
                <button onclick="newGame()" class="primary">‚ôüÔ∏è –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                <button onclick="undoMove()">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞</button>
                <button onclick="toggleSide()">üîÑ –°–º–µ–Ω–∏—Ç—å —Ü–≤–µ—Ç</button>
                <button onclick="flipBoard()">üîÑ –ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å</button>
            </div>

            <div class="moves-section">
                <h3>üìù –•–æ–¥—ã –∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã</h3>
                <div class="moves-list" id="movesList">
                    <div class="move-item">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                </div>
                <div class="notation" id="pgnNotation"></div>
            </div>

            <div class="status" id="gameStatus">
                –•–æ–¥ –±–µ–ª—ã—Ö
            </div>
        </div>
    </div>

    <script>
        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —Ñ–∏–≥—É—Ä
        const PIECES = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };

        // –ù–∞—á–∞–ª—å–Ω–∞—è FEN –ø–æ–∑–∏—Ü–∏—è
        const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
        let board = [];
        let currentPlayer = 'w';
        let selectedSquare = null;
        let validMoves = [];
        let gameMoves = [];
        let currentMoveIndex = -1;
        let boardFlipped = false;
        let lastMove = null;
        let castling = 'KQkq';
        let enPassant = '-';
        let halfMoveClock = 0;
        let fullMoveNumber = 1;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–æ—Å–∫–∏
        function initBoard() {
            loadPositionFromFEN(START_FEN);
            renderBoard();
            getCloudEvaluation();
        }

        // –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ FEN
        function loadPositionFromFEN(fen) {
            const parts = fen.split(' ');
            const position = parts[0];
            currentPlayer = parts[1] || 'w';
            castling = parts[2] || 'KQkq';
            enPassant = parts[3] || '-';
            halfMoveClock = parseInt(parts[4]) || 0;
            fullMoveNumber = parseInt(parts[5]) || 1;

            // –ü–∞—Ä—Å–∏–º –ø–æ–∑–∏—Ü–∏—é
            const rows = position.split('/');
            board = [];
            for (let i = 0; i < 8; i++) {
                const row = [];
                let col = 0;
                for (let char of rows[i]) {
                    if (isNaN(char)) {
                        row[col] = char;
                        col++;
                    } else {
                        for (let j = 0; j < parseInt(char); j++) {
                            row[col] = '';
                            col++;
                        }
                    }
                }
                board.push(row);
            }

            updateGameStatus();
            document.getElementById('fenInput').value = fen;
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ FEN –∏–∑ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏
        function getFEN() {
            let fen = '';
            for (let i = 0; i < 8; i++) {
                let emptyCount = 0;
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece === '') {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        fen += piece;
                    }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (i < 7) fen += '/';
            }
            fen += ` ${currentPlayer} ${castling} ${enPassant} ${halfMoveClock} ${fullMoveNumber}`;
            return fen;
        }

        // –†–µ–Ω–¥–µ—Ä –¥–æ—Å–∫–∏
        function renderBoard() {
            const boardElement = document.getElementById('chessBoard');
            boardElement.innerHTML = '';

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const row = boardFlipped ? 7 - i : i;
                    const col = boardFlipped ? 7 - j : j;
                    const piece = board[row][col];
                    
                    const square = document.createElement('div');
                    square.className = `square ${(i + j) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ö–æ–¥–∞
                    if (lastMove && ((lastMove.from.row === row && lastMove.from.col === col) || 
                                    (lastMove.to.row === row && lastMove.to.col === col))) {
                        square.classList.add('last-move');
                    }
                    
                    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–ª–µ—Ç–∫–∏
                    if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                        square.classList.add('selected');
                    }
                    
                    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤
                    if (validMoves.some(m => m.to.row === row && m.to.col === col)) {
                        const move = validMoves.find(m => m.to.row === row && m.to.col === col);
                        if (move.capture) {
                            square.classList.add('valid-capture');
                        } else {
                            square.classList.add('valid-move');
                        }
                    }
                    
                    if (piece) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.className = 'piece';
                        pieceSpan.textContent = PIECES[piece];
                        pieceSpan.style.color = piece === piece.toUpperCase() ? 'white' : 'black';
                        pieceSpan.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                        square.appendChild(pieceSpan);
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ –∫–ª–µ—Ç–∫–µ
        function handleSquareClick(row, col) {
            const piece = board[row][col];
            
            if (selectedSquare === null) {
                // –í—ã–±–∏—Ä–∞–µ–º —Ñ–∏–≥—É—Ä—É
                if (piece && ((currentPlayer === 'w' && piece === piece.toUpperCase()) ||
                             (currentPlayer === 'b' && piece === piece.toLowerCase()))) {
                    selectedSquare = { row, col };
                    validMoves = getValidMoves(row, col);
                    renderBoard();
                }
            } else {
                // –î–µ–ª–∞–µ–º —Ö–æ–¥
                const move = validMoves.find(m => m.to.row === row && m.to.col === col);
                if (move) {
                    makeMove(selectedSquare, { row, col }, move.promotion);
                }
                selectedSquare = null;
                validMoves = [];
                renderBoard();
            }
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –≤–∞–ª–∏–¥–Ω—ã—Ö —Ö–æ–¥–æ–≤ –¥–ª—è —Ñ–∏–≥—É—Ä—ã
        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            
            const moves = [];
            const isWhite = piece === piece.toUpperCase();
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ñ–∏–≥—É—Ä
            const directions = {
                'P': isWhite ? [[-1, 0]] : [[1, 0]],
                'N': [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]],
                'B': [[-1, -1], [-1, 1], [1, -1], [1, 1]],
                'R': [[-1, 0], [1, 0], [0, -1], [0, 1]],
                'Q': [[-1, -1], [-1, 1], [1, -1], [1, 1], [-1, 0], [1, 0], [0, -1], [0, 1]],
                'K': [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
            };
            
            let pieceType = piece.toUpperCase();
            let dirs = directions[pieceType] || [];
            
            for (let [dx, dy] of dirs) {
                let newRow = row + dx;
                let newCol = col + dy;
                
                if (pieceType === 'P') {
                    // –ü–µ—à–∫–∞
                    if (dx === -1 && dy === 0 && isWhite) {
                        if (newRow >= 0 && board[newRow][newCol] === '') {
                            moves.push({ to: { row: newRow, col: newCol } });
                            if (row === 6) {
                                let newRow2 = row - 2;
                                if (board[newRow2][newCol] === '') {
                                    moves.push({ to: { row: newRow2, col: newCol } });
                                }
                            }
                        }
                    } else if (dx === 1 && dy === 0 && !isWhite) {
                        if (newRow < 8 && board[newRow][newCol] === '') {
                            moves.push({ to: { row: newRow, col: newCol } });
                            if (row === 1) {
                                let newRow2 = row + 2;
                                if (board[newRow2][newCol] === '') {
                                    moves.push({ to: { row: newRow2, col: newCol } });
                                }
                            }
                        }
                    } else if (Math.abs(dy) === 1) {
                        // –í–∑—è—Ç–∏–µ
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            const target = board[newRow][newCol];
                            if (target && ((isWhite && target === target.toLowerCase()) ||
                                         (!isWhite && target === target.toUpperCase()))) {
                                moves.push({ to: { row: newRow, col: newCol }, capture: true });
                            }
                            // –í–∑—è—Ç–∏–µ –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ
                            if (enPassant !== '-') {
                                const epRow = isWhite ? 3 : 4;
                                const epCol = enPassant.charCodeAt(0) - 'a'.charCodeAt(0);
                                if (row === epRow && col === epCol - dy) {
                                    moves.push({ to: { row: newRow, col: newCol }, capture: true, enPassant: true });
                                }
                            }
                        }
                    }
                    continue;
                }
                
                // –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ñ–∏–≥—É—Ä
                while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = board[newRow][newCol];
                    
                    if (target === '') {
                        moves.push({ to: { row: newRow, col: newCol } });
                    } else {
                        if ((isWhite && target === target.toLowerCase()) ||
                            (!isWhite && target === target.toUpperCase())) {
                            moves.push({ to: { row: newRow, col: newCol }, capture: true });
                        }
                        break;
                    }
                    
                    if (pieceType === 'N' || pieceType === 'K') break;
                    newRow += dx;
                    newCol += dy;
                }
            }
            
            // –†–æ–∫–∏—Ä–æ–≤–∫–∞
            if (pieceType === 'K') {
                const kingRow = isWhite ? 7 : 0;
                if (row === kingRow && col === 4) {
                    if (castling.includes(isWhite ? 'K' : 'k') && 
                        board[kingRow][5] === '' && board[kingRow][6] === '' &&
                        !isSquareUnderAttack(kingRow, 4, isWhite) &&
                        !isSquareUnderAttack(kingRow, 5, isWhite) &&
                        !isSquareUnderAttack(kingRow, 6, isWhite)) {
                        moves.push({ to: { row: kingRow, col: 6 }, castling: 'short' });
                    }
                    if (castling.includes(isWhite ? 'Q' : 'q') && 
                        board[kingRow][3] === '' && board[kingRow][2] === '' && board[kingRow][1] === '' &&
                        !isSquareUnderAttack(kingRow, 4, isWhite) &&
                        !isSquareUnderAttack(kingRow, 3, isWhite) &&
                        !isSquareUnderAttack(kingRow, 2, isWhite)) {
                        moves.push({ to: { row: kingRow, col: 2 }, castling: 'long' });
                    }
                }
            }
            
            return moves;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞, –∞—Ç–∞–∫–æ–≤–∞–Ω–∞ –ª–∏ –∫–ª–µ—Ç–∫–∞
        function isSquareUnderAttack(row, col, isWhite) {
            // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –Ω—É–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–ª–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É
            return false;
        }

        // –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ö–æ–¥–∞
        function makeMove(from, to, promotion = 'q') {
            const piece = board[from.row][from.col];
            const target = board[to.row][to.col];
            const isWhite = piece === piece.toUpperCase();
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ö–æ–¥–µ
            const move = {
                from,
                to,
                piece,
                capture: target !== '',
                promotion: null,
                castling: null,
                enPassant: false
            };
            
            // –î–≤–∏–∂–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã
            board[to.row][to.col] = piece;
            board[from.row][from.col] = '';
            
            // –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏
            if (piece.toUpperCase() === 'P' && (to.row === 0 || to.row === 7)) {
                board[to.row][to.col] = isWhite ? promotion.toUpperCase() : promotion.toLowerCase();
                move.promotion = promotion;
            }
            
            // –†–æ–∫–∏—Ä–æ–≤–∫–∞
            if (piece.toUpperCase() === 'K' && Math.abs(to.col - from.col) === 2) {
                if (to.col === 6) {
                    board[to.row][5] = board[to.row][7];
                    board[to.row][7] = '';
                } else if (to.col === 2) {
                    board[to.row][3] = board[to.row][0];
                    board[to.row][0] = '';
                }
                move.castling = to.col === 6 ? 'short' : 'long';
            }
            
            // –í–∑—è—Ç–∏–µ –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ
            if (piece.toUpperCase() === 'P' && enPassant !== '-' && to.col === enPassant.charCodeAt(0) - 'a'.charCodeAt(0)) {
                const epRow = isWhite ? to.row + 1 : to.row - 1;
                if (board[epRow][to.col] !== '') {
                    board[epRow][to.col] = '';
                    move.enPassant = true;
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–æ–∫–∏—Ä–æ–≤–æ—á–Ω—ã—Ö –ø—Ä–∞–≤
            if (piece.toUpperCase() === 'K') {
                castling = castling.replace(isWhite ? /[KQ]/g : /[kq]/g, '');
            }
            if (piece.toUpperCase() === 'R') {
                if (from.row === (isWhite ? 7 : 0)) {
                    if (from.col === 0) castling = castling.replace(isWhite ? 'Q' : 'q', '');
                    if (from.col === 7) castling = castling.replace(isWhite ? 'K' : 'k', '');
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ enPassant
            if (piece.toUpperCase() === 'P' && Math.abs(to.row - from.row) === 2) {
                enPassant = String.fromCharCode('a'.charCodeAt(0) + from.col) + (isWhite ? '3' : '6');
            } else {
                enPassant = '-';
            }
            
            // –°–º–µ–Ω–∞ –∏–≥—Ä–æ–∫–∞
            currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
            fullMoveNumber += currentPlayer === 'w' ? 1 : 0;
            if (target !== '' || piece.toUpperCase() === 'P') halfMoveClock = 0;
            else halfMoveClock++;
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ö–æ–¥
            gameMoves = gameMoves.slice(0, currentMoveIndex + 1);
            gameMoves.push(move);
            currentMoveIndex++;
            lastMove = move;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
            updateGameStatus();
            renderBoard();
            updateMovesList();
            getCloudEvaluation();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∞—Ç/–ø–∞—Ç
            checkGameEnd();
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã
        function checkGameEnd() {
            const isWhite = currentPlayer === 'w';
            let hasMoves = false;
            
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece && ((isWhite && piece === piece.toUpperCase()) ||
                                 (!isWhite && piece === piece.toLowerCase()))) {
                        const moves = getValidMoves(i, j);
                        if (moves.length > 0) {
                            hasMoves = true;
                            break;
                        }
                    }
                }
                if (hasMoves) break;
            }
            
            if (!hasMoves) {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —à–∞—Ö (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
                const status = document.getElementById('gameStatus');
                status.textContent = '–ú–∞—Ç! ' + (currentPlayer === 'w' ? '–ß–µ—Ä–Ω—ã–µ' : '–ë–µ–ª—ã–µ') + ' –ø–æ–±–µ–¥–∏–ª–∏!';
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∏–≥—Ä—ã
        function updateGameStatus() {
            const status = document.getElementById('gameStatus');
            status.textContent = currentPlayer === 'w' ? '–•–æ–¥ –±–µ–ª—ã—Ö' : '–•–æ–¥ —á–µ—Ä–Ω—ã—Ö';
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ö–æ–¥–æ–≤
        function updateMovesList() {
            const movesList = document.getElementById('movesList');
            const pgnNotation = document.getElementById('pgnNotation');
            
            if (gameMoves.length === 0) {
                movesList.innerHTML = '<div class="move-item">–ù–µ—Ç —Ö–æ–¥–æ–≤</div>';
                pgnNotation.textContent = '';
                return;
            }
            
            movesList.innerHTML = '';
            let pgn = '';
            
            for (let i = 0; i < gameMoves.length; i++) {
                const move = gameMoves[i];
                const moveNumber = Math.floor(i / 2) + 1;
                const isWhiteMove = i % 2 === 0;
                
                if (isWhiteMove) {
                    pgn += moveNumber + '. ';
                }
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫—É—é –Ω–æ—Ç–∞—Ü–∏—é (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
                let notation = '';
                const piece = move.piece.toUpperCase();
                if (piece !== 'P') {
                    notation += piece;
                }
                notation += String.fromCharCode('a'.charCodeAt(0) + move.to.col) + (8 - move.to.row);
                if (move.capture) notation = notation.replace(/[a-h][1-8]/, 'x' + notation.slice(-2));
                if (move.promotion) notation += '=' + move.promotion.toUpperCase();
                
                pgn += notation + ' ';
                
                const moveItem = document.createElement('div');
                moveItem.className = 'move-item' + (i === currentMoveIndex ? ' current' : '');
                moveItem.textContent = (isWhiteMove ? moveNumber + '. ' : '') + notation;
                moveItem.addEventListener('click', () => goToMove(i));
                movesList.appendChild(moveItem);
            }
            
            pgnNotation.textContent = pgn;
        }

        // –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Ö–æ–¥—É
        function goToMove(index) {
            loadPositionFromFEN(START_FEN);
            for (let i = 0; i <= index; i++) {
                const move = gameMoves[i];
                makeMove(move.from, move.to, move.promotion);
            }
            currentMoveIndex = index;
            updateMovesList();
            getCloudEvaluation();
        }

        // –û—Ç–º–µ–Ω–∞ —Ö–æ–¥–∞
        function undoMove() {
            if (currentMoveIndex >= 0) {
                loadPositionFromFEN(START_FEN);
                for (let i = 0; i < currentMoveIndex; i++) {
                    const move = gameMoves[i];
                    makeMove(move.from, move.to, move.promotion);
                }
                gameMoves.pop();
                currentMoveIndex--;
                updateMovesList();
                getCloudEvaluation();
            }
        }

        // –ù–æ–≤–∞—è –∏–≥—Ä–∞
        function newGame() {
            loadPositionFromFEN(START_FEN);
            gameMoves = [];
            currentMoveIndex = -1;
            lastMove = null;
            selectedSquare = null;
            validMoves = [];
            renderBoard();
            updateMovesList();
            getCloudEvaluation();
        }

        // –ü–µ—Ä–µ–≤–æ—Ä–æ—Ç –¥–æ—Å–∫–∏
        function flipBoard() {
            boardFlipped = !boardFlipped;
            renderBoard();
        }

        // –°–º–µ–Ω–∞ —Å—Ç–æ—Ä–æ–Ω—ã
        function toggleSide() {
            currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
            updateGameStatus();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ FEN
        function updatePositionFromFEN() {
            const fen = document.getElementById('fenInput').value;
            loadPositionFromFEN(fen);
            gameMoves = [];
            currentMoveIndex = -1;
            lastMove = null;
            selectedSquare = null;
            validMoves = [];
            renderBoard();
            updateMovesList();
            getCloudEvaluation();
        }

        // –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ü–µ–Ω–∫–∏ –æ—Ç Lichess API
        async function getCloudEvaluation() {
            const fen = getFEN();
            const evalValue = document.getElementById('evalValue');
            const evalBar = document.getElementById('evalBar');
            const evalDepth = document.getElementById('evalDepth');
            
            evalValue.innerHTML = '<span class="loading"></span>';
            
            try {
                const response = await fetch(`https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}&multiPv=3`);
                
                if (response.status === 404) {
                    evalValue.textContent = '–ù–µ—Ç –æ—Ü–µ–Ω–∫–∏';
                    evalValue.style.color = '#7f8c8d';
                    evalBar.style.width = '50%';
                    evalDepth.textContent = '';
                    return;
                }
                
                const data = await response.json();
                
                if (data.pvs && data.pvs.length > 0) {
                    const cp = data.pvs[0].cp;
                    const mate = data.pvs[0].mate;
                    
                    let evalText = '';
                    let evalPercent = 50;
                    
                    if (mate) {
                        evalText = `#${mate}`;
                        evalPercent = mate > 0 ? 100 : 0;
                        evalValue.style.color = mate > 0 ? '#2ecc71' : '#e74c3c';
                    } else if (cp !== undefined) {
                        const cpValue = cp / 100;
                        evalText = cpValue.toFixed(2);
                        evalValue.style.color = cpValue > 0 ? '#2ecc71' : cpValue < 0 ? '#e74c3c' : '#f1c40f';
                        
                        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è CP –≤ –ø—Ä–æ—Ü–µ–Ω—Ç—ã –¥–ª—è –±–∞—Ä–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
                        evalPercent = Math.min(100, Math.max(0, 50 + cpValue * 5));
                    }
                    
                    evalValue.textContent = evalText;
                    evalBar.style.width = evalPercent + '%';
                    evalDepth.textContent = `–ì–ª—É–±–∏–Ω–∞: ${data.depth} | –í–∞—Ä–∏–∞–Ω—Ç–æ–≤: ${data.pvs.length}`;
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–∞—Ä–∏–∞–Ω—Ç—ã
                    const movesList = document.getElementById('movesList');
                    movesList.innerHTML = '<h4>–í–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç Lichess:</h4>';
                    
                    data.pvs.forEach((pv, index) => {
                        const moveItem = document.createElement('div');
                        moveItem.className = 'move-item';
                        let value = pv.cp ? (pv.cp / 100).toFixed(2) : `#${pv.mate}`;
                        moveItem.textContent = `${index + 1}. ${value} | ${pv.moves}`;
                        movesList.appendChild(moveItem);
                    });
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ü–µ–Ω–∫–∏:', error);
                evalValue.textContent = '–û—à–∏–±–∫–∞ API';
                evalValue.style.color = '#e74c3c';
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.onload = initBoard;
    </script>
</body>
</html>
