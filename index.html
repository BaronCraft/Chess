<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Analysis —Å Lichess API</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2f2a 0%, #23453b 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: #2b2b2b;
            border-radius: 24px;
            padding: 30px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
        }
        
        .board-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 80px);
            grid-template-rows: repeat(8, 80px);
            border: 4px solid #3a5a4a;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }
        
        .square {
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 60px;
            cursor: pointer;
            transition: all 0.15s;
            user-select: none;
            position: relative;
        }
        
        /* –ë–µ–ª–æ-–∑–µ–ª–µ–Ω–∞—è —Ç–µ–º–∞ –¥–æ—Å–∫–∏ */
        .square.light {
            background-color: #eeeed5;
        }
        
        .square.dark {
            background-color: #7d9f7d;
        }
        
        .white-piece {
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6), -1px -1px 0 rgba(255,255,255,0.3);
            filter: drop-shadow(3px 3px 3px rgba(0,0,0,0.4));
            font-weight: 500;
            transition: transform 0.2s;
            cursor: grab;
        }
        
        .black-piece {
            color: #222222;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.4), -1px -1px 0 rgba(0,0,0,0.3);
            filter: drop-shadow(3px 3px 3px rgba(0,0,0,0.5));
            font-weight: 500;
            transition: transform 0.2s;
            cursor: grab;
        }
        
        .white-piece:active, .black-piece:active {
            cursor: grabbing;
            transform: scale(1.05);
        }
        
        .square.selected {
            background-color: #b5d6b5 !important;
            box-shadow: inset 0 0 0 3px #2e7d32;
        }
        
        .square.possible-move {
            position: relative;
        }
        
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            background-color: rgba(46, 125, 50, 0.4);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(46, 125, 50, 0.5);
        }
        
        .square.possible-capture::after {
            content: '';
            position: absolute;
            width: 70px;
            height: 70px;
            border: 4px solid rgba(198, 40, 40, 0.5);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(198, 40, 40, 0.3);
        }
        
        .square.last-move {
            background-color: #c9ddc9 !important;
        }
        
        .square.drag-over {
            background-color: #a5c9a5 !important;
            box-shadow: inset 0 0 0 3px #ffd700;
        }
        
        .info-panel {
            background: #353535;
            border-radius: 18px;
            padding: 25px;
            color: white;
            min-width: 300px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .status {
            background: #404040;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            border-left: 4px solid #7d9f7d;
        }
        
        .engine-status {
            background: #2a5a4a;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 14px;
            color: #ffd700;
        }
        
        .material-difference {
            background: #404040;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .material-title {
            text-align: center;
            margin-bottom: 15px;
            color: #aaa;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .material-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 5px;
            background: #4a4a4a;
            border-radius: 8px;
        }
        
        .material-pieces {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            min-height: 45px;
        }
        
        .piece-icon {
            font-size: 28px;
            width: 35px;
            height: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #555;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .advantage {
            font-weight: bold;
            padding: 5px 12px;
            border-radius: 20px;
            background: #333;
            font-size: 16px;
        }
        
        .advantage.white {
            color: #4CAF50;
            background: #1e3a2a;
        }
        
        .advantage.black {
            color: #f44336;
            background: #3a1e1e;
        }
        
        .advantage.equal {
            color: #ffc107;
            background: #3a3a1e;
        }
        
        .moves-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 10px;
            background: #333;
            border-radius: 10px;
            scrollbar-width: thin;
            scrollbar-color: #7d9f7d #404040;
        }
        
        .moves-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .moves-list::-webkit-scrollbar-track {
            background: #404040;
        }
        
        .moves-list::-webkit-scrollbar-thumb {
            background: #7d9f7d;
            border-radius: 4px;
        }
        
        .move-item {
            padding: 10px 15px;
            margin: 5px 0;
            background: #3d3d3d;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        
        .move-item:hover {
            background: #4a4a4a;
            transform: translateX(5px);
        }
        
        .move-number {
            color: #ffd700;
            font-weight: bold;
        }
        
        .move-white {
            color: #fff;
        }
        
        .move-black {
            color: #ccc;
        }
        
        .buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        button {
            padding: 14px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 15px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 4px 0 #2d5a2d;
        }
        
        button:hover {
            background: #5cb860;
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #2d5a2d;
        }
        
        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #2d5a2d;
        }
        
        button.reset {
            background: #f44336;
            box-shadow: 0 4px 0 #a33a33;
        }
        
        button.reset:hover {
            background: #ff5a4a;
        }
        
        button.engine {
            background: #7d9f7d;
            box-shadow: 0 4px 0 #4a6b4a;
        }
        
        /* –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è –ø–µ—à–∫–∏ */
        .promotion-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }
        
        .promotion-content {
            background: #353535;
            padding: 35px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
            border: 2px solid #7d9f7d;
        }
        
        .promotion-title {
            color: white;
            margin-bottom: 25px;
            font-size: 22px;
            font-weight: bold;
        }
        
        .promotion-pieces {
            display: flex;
            gap: 25px;
            justify-content: center;
        }
        
        .promotion-piece {
            width: 90px;
            height: 90px;
            background: #4a4a4a;
            border: 3px solid #666;
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 70px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 5px 0 #333;
        }
        
        .promotion-piece:hover {
            background: #5a5a5a;
            border-color: #7d9f7d;
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 10px 0 #333;
        }
        
        .promotion-piece.white-piece {
            color: #fff;
        }
        
        .promotion-piece.black-piece {
            color: #222;
        }
        
        @media (max-width: 768px) {
            .chess-board {
                grid-template-columns: repeat(8, 55px);
                grid-template-rows: repeat(8, 55px);
            }
            
            .square {
                width: 55px;
                height: 55px;
                font-size: 42px;
            }
            
            .promotion-piece {
                width: 65px;
                height: 65px;
                font-size: 50px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board-container">
            <div class="chess-board" id="chessBoard"></div>
            
            <div class="info-panel">
                <div class="status" id="gameStatus">–•–æ–¥ –±–µ–ª—ã—Ö</div>
                
                <div class="engine-status" id="engineStatus">
                    Lichess API: –ê–Ω–∞–ª–∏–∑ –¥–æ—Å—Ç—É–ø–µ–Ω
                </div>
                
                <div class="material-difference" id="materialDifference">
                    <div class="material-title">–ú–ê–¢–ï–†–ò–ê–õ–¨–ù–´–ô –ü–ï–†–ï–í–ï–°</div>
                    <div class="material-row">
                        <span>‚ö™ –ë–µ–ª—ã–µ:</span>
                        <div class="material-pieces" id="whiteMaterial"></div>
                    </div>
                    <div class="material-row">
                        <span>‚ö´ –ß–µ—Ä–Ω—ã–µ:</span>
                        <div class="material-pieces" id="blackMaterial"></div>
                    </div>
                    <div class="material-row">
                        <span>üìä –ü–µ—Ä–µ–≤–µ—Å:</span>
                        <span id="advantageText" class="advantage equal">–†–∞–≤–Ω–æ</span>
                    </div>
                </div>
                
                <div class="moves-list" id="movesList">
                    <div style="text-align: center; color: #888;">–ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤</div>
                </div>
                
                <div class="buttons">
                    <button onclick="chessGame.resetGame()" class="reset">üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                    <button onclick="chessGame.undoMove()">‚Ü©Ô∏è –û—Ç–º–µ–Ω–∞</button>
                    <button onclick="chessGame.getEngineAnalysis()" class="engine">ü§ñ –ê–Ω–∞–ª–∏–∑</button>
                    <button onclick="chessGame.flipBoard()">üîÑ –ü–æ–≤–µ—Ä–Ω—É—Ç—å</button>
                </div>
            </div>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è –ø–µ—à–∫–∏ -->
    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-content">
            <div class="promotion-title">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É –¥–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è</div>
            <div class="promotion-pieces" id="promotionPieces"></div>
        </div>
    </div>

    <script>
        class ChessGame {
            constructor() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.analysisMode = false;
                this.boardFlipped = false;
                this.lastMove = null;
                this.castlingRights = {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                };
                this.enPassantTarget = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                this.pendingPromotion = null;
                this.draggedPiece = null;
                
                this.initBoard();
                this.setupDragAndDrop();
            }
            
            createInitialBoard() {
                return [
                    ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                    ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
                    ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
                ];
            }
            
            initBoard() {
                this.renderBoard();
                this.updateStatus();
                this.updateMaterialDifference();
            }
            
            setupDragAndDrop() {
                document.addEventListener('dragstart', (e) => {
                    const piece = e.target.closest('.white-piece, .black-piece');
                    if (!piece) {
                        e.preventDefault();
                        return;
                    }
                    
                    const square = piece.closest('.square');
                    if (!square) return;
                    
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    const boardPiece = this.board[row][col];
                    
                    if (this.getPieceColor(boardPiece) !== this.currentPlayer) {
                        e.preventDefault();
                        return;
                    }
                    
                    this.draggedPiece = { row, col, element: piece };
                    e.dataTransfer.setData('text/plain', `${row},${col}`);
                    e.dataTransfer.effectAllowed = 'move';
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ö–æ–¥—ã
                    this.selectedSquare = { row, col };
                    this.possibleMoves = this.getValidMoves(row, col);
                    this.renderBoard();
                });
                
                document.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    const square = e.target.closest('.square');
                    if (square) {
                        square.classList.add('drag-over');
                    }
                });
                
                document.addEventListener('dragleave', (e) => {
                    const square = e.target.closest('.square');
                    if (square) {
                        square.classList.remove('drag-over');
                    }
                });
                
                document.addEventListener('drop', (e) => {
                    e.preventDefault();
                    
                    const square = e.target.closest('.square');
                    if (!square) return;
                    
                    square.classList.remove('drag-over');
                    
                    if (!this.draggedPiece) return;
                    
                    const fromRow = this.draggedPiece.row;
                    const fromCol = this.draggedPiece.col;
                    const toRow = parseInt(square.dataset.row);
                    const toCol = parseInt(square.dataset.col);
                    
                    const move = this.possibleMoves.find(m => 
                        m.to.row === toRow && m.to.col === toCol
                    );
                    
                    if (move) {
                        this.makeMove(move);
                    }
                    
                    this.draggedPiece = null;
                    this.selectedSquare = null;
                    this.possibleMoves = [];
                    this.renderBoard();
                });
                
                document.addEventListener('dragend', (e) => {
                    this.draggedPiece = null;
                    this.selectedSquare = null;
                    this.possibleMoves = [];
                    this.renderBoard();
                });
            }
            
            renderBoard() {
                const boardElement = document.getElementById('chessBoard');
                boardElement.innerHTML = '';
                
                let boardToRender = this.board;
                if (this.boardFlipped) {
                    boardToRender = this.flipBoardArray(this.board);
                }
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const actualRow = this.boardFlipped ? 7 - row : row;
                        const actualCol = this.boardFlipped ? 7 - col : col;
                        
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = actualRow;
                        square.dataset.col = actualCol;
                        
                        const piece = boardToRender[row][col];
                        if (piece) {
                            const pieceSpan = document.createElement('span');
                            pieceSpan.textContent = piece;
                            pieceSpan.className = this.getPieceColor(piece) === 'white' ? 'white-piece' : 'black-piece';
                            pieceSpan.setAttribute('draggable', this.getPieceColor(piece) === this.currentPlayer);
                            square.appendChild(pieceSpan);
                        }
                        
                        if (this.selectedSquare && 
                            this.selectedSquare.row === actualRow && 
                            this.selectedSquare.col === actualCol) {
                            square.classList.add('selected');
                        }
                        
                        if (this.lastMove) {
                            if ((actualRow === this.lastMove.from.row && actualCol === this.lastMove.from.col) ||
                                (actualRow === this.lastMove.to.row && actualCol === this.lastMove.to.col)) {
                                square.classList.add('last-move');
                            }
                        }
                        
                        this.possibleMoves.forEach(move => {
                            if (move.to.row === actualRow && move.to.col === actualCol) {
                                if (this.board[actualRow][actualCol]) {
                                    square.classList.add('possible-capture');
                                } else {
                                    square.classList.add('possible-move');
                                }
                            }
                        });
                        
                        square.addEventListener('click', () => this.handleSquareClick(actualRow, actualCol));
                        boardElement.appendChild(square);
                    }
                }
            }
            
            flipBoardArray(board) {
                const flipped = [];
                for (let i = 0; i < 8; i++) {
                    flipped[i] = [];
                    for (let j = 0; j < 8; j++) {
                        flipped[i][j] = board[7 - i][7 - j];
                    }
                }
                return flipped;
            }
            
            handleSquareClick(row, col) {
                const piece = this.board[row][col];
                
                if (this.selectedSquare) {
                    const move = this.possibleMoves.find(m => m.to.row === row && m.to.col === col);
                    
                    if (move) {
                        this.makeMove(move);
                        this.selectedSquare = null;
                        this.possibleMoves = [];
                    } else {
                        if (piece && this.getPieceColor(piece) === this.currentPlayer) {
                            this.selectedSquare = { row, col };
                            this.possibleMoves = this.getValidMoves(row, col);
                        } else {
                            this.selectedSquare = null;
                            this.possibleMoves = [];
                        }
                    }
                } else {
                    if (piece && this.getPieceColor(piece) === this.currentPlayer) {
                        this.selectedSquare = { row, col };
                        this.possibleMoves = this.getValidMoves(row, col);
                    }
                }
                
                this.renderBoard();
            }
            
            getPieceColor(piece) {
                if (!piece) return null;
                const whitePieces = ['‚ôî', '‚ôï', '‚ôñ', '‚ôó', '‚ôò', '‚ôô'];
                const blackPieces = ['‚ôö', '‚ôõ', '‚ôú', '‚ôù', '‚ôû', '‚ôü'];
                if (whitePieces.includes(piece)) return 'white';
                if (blackPieces.includes(piece)) return 'black';
                return null;
            }
            
            getValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const color = this.getPieceColor(piece);
                if (color !== this.currentPlayer) return [];
                
                const moves = [];
                
                switch(piece) {
                    case '‚ôô': this.getPawnMoves(row, col, 'white', moves); break;
                    case '‚ôü': this.getPawnMoves(row, col, 'black', moves); break;
                    case '‚ôñ': case '‚ôú': this.getRookMoves(row, col, moves); break;
                    case '‚ôò': case '‚ôû': this.getKnightMoves(row, col, moves); break;
                    case '‚ôó': case '‚ôù': this.getBishopMoves(row, col, moves); break;
                    case '‚ôï': case '‚ôõ': this.getQueenMoves(row, col, moves); break;
                    case '‚ôî': case '‚ôö': this.getKingMoves(row, col, color, moves); break;
                }
                
                return moves.filter(move => !this.wouldBeInCheck(row, col, move.to.row, move.to.col, color));
            }
            
            getPawnMoves(row, col, color, moves) {
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                if (this.isInBounds(row + direction, col) && !this.board[row + direction][col]) {
                    moves.push({ from: { row, col }, to: { row: row + direction, col } });
                    
                    if (row === startRow && !this.board[row + 2 * direction][col]) {
                        moves.push({ from: { row, col }, to: { row: row + 2 * direction, col } });
                    }
                }
                
                [-1, 1].forEach(offset => {
                    const newCol = col + offset;
                    if (this.isInBounds(row + direction, newCol)) {
                        const targetPiece = this.board[row + direction][newCol];
                        if (targetPiece && this.getPieceColor(targetPiece) !== color) {
                            moves.push({ from: { row, col }, to: { row: row + direction, col: newCol } });
                        }
                        
                        if (this.enPassantTarget && 
                            this.enPassantTarget.row === row + direction && 
                            this.enPassantTarget.col === newCol) {
                            moves.push({ 
                                from: { row, col }, 
                                to: { row: row + direction, col: newCol },
                                enPassant: true 
                            });
                        }
                    }
                });
            }
            
            getRookMoves(row, col, moves) {
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                this.getSlidingMoves(row, col, directions, moves);
            }
            
            getBishopMoves(row, col, moves) {
                const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                this.getSlidingMoves(row, col, directions, moves);
            }
            
            getQueenMoves(row, col, moves) {
                const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                this.getSlidingMoves(row, col, directions, moves);
            }
            
            getKnightMoves(row, col, moves) {
                const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                const pieceColor = this.getPieceColor(this.board[row][col]);
                
                knightMoves.forEach(([rowOffset, colOffset]) => {
                    const newRow = row + rowOffset;
                    const newCol = col + colOffset;
                    
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || this.getPieceColor(targetPiece) !== pieceColor) {
                            moves.push({ from: { row, col }, to: { row: newRow, col: newCol } });
                        }
                    }
                });
            }
            
            getKingMoves(row, col, color, moves) {
                const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                
                kingMoves.forEach(([rowOffset, colOffset]) => {
                    const newRow = row + rowOffset;
                    const newCol = col + colOffset;
                    
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || this.getPieceColor(targetPiece) !== color) {
                            moves.push({ from: { row, col }, to: { row: newRow, col: newCol } });
                        }
                    }
                });
                
                // –†–æ–∫–∏—Ä–æ–≤–∫–∞
                if (color === 'white' && row === 7 && col === 4) {
                    if (this.castlingRights.white.kingside && 
                        !this.board[7][5] && !this.board[7][6] &&
                        !this.isSquareAttacked(7, 4, 'white') &&
                        !this.isSquareAttacked(7, 5, 'white') &&
                        !this.isSquareAttacked(7, 6, 'white')) {
                        moves.push({ from: { row, col }, to: { row: 7, col: 6 }, castle: 'kingside' });
                    }
                    if (this.castlingRights.white.queenside && 
                        !this.board[7][3] && !this.board[7][2] && !this.board[7][1] &&
                        !this.isSquareAttacked(7, 4, 'white') &&
                        !this.isSquareAttacked(7, 3, 'white') &&
                        !this.isSquareAttacked(7, 2, 'white')) {
                        moves.push({ from: { row, col }, to: { row: 7, col: 2 }, castle: 'queenside' });
                    }
                }
                
                if (color === 'black' && row === 0 && col === 4) {
                    if (this.castlingRights.black.kingside && 
                        !this.board[0][5] && !this.board[0][6] &&
                        !this.isSquareAttacked(0, 4, 'black') &&
                        !this.isSquareAttacked(0, 5, 'black') &&
                        !this.isSquareAttacked(0, 6, 'black')) {
                        moves.push({ from: { row, col }, to: { row: 0, col: 6 }, castle: 'kingside' });
                    }
                    if (this.castlingRights.black.queenside && 
                        !this.board[0][3] && !this.board[0][2] && !this.board[0][1] &&
                        !this.isSquareAttacked(0, 4, 'black') &&
                        !this.isSquareAttacked(0, 3, 'black') &&
                        !this.isSquareAttacked(0, 2, 'black')) {
                        moves.push({ from: { row, col }, to: { row: 0, col: 2 }, castle: 'queenside' });
                    }
                }
            }
            
            getSlidingMoves(row, col, directions, moves) {
                const pieceColor = this.getPieceColor(this.board[row][col]);
                
                directions.forEach(([rowDir, colDir]) => {
                    let newRow = row + rowDir;
                    let newCol = col + colDir;
                    
                    while (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        
                        if (!targetPiece) {
                            moves.push({ from: { row, col }, to: { row: newRow, col: newCol } });
                        } else {
                            if (this.getPieceColor(targetPiece) !== pieceColor) {
                                moves.push({ from: { row, col }, to: { row: newRow, col: newCol } });
                            }
                            break;
                        }
                        
                        newRow += rowDir;
                        newCol += colDir;
                    }
                });
            }
            
            isSquareAttacked(row, col, defendingColor) {
                const attackingColor = defendingColor === 'white' ? 'black' : 'white';
                
                // –ü–µ—à–∫–∏
                const pawnDirection = defendingColor === 'white' ? -1 : 1;
                for (const offset of [-1, 1]) {
                    const attackRow = row + pawnDirection;
                    const attackCol = col + offset;
                    if (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece && this.getPieceColor(piece) === attackingColor) {
                            if ((defendingColor === 'white' && piece === '‚ôü') ||
                                (defendingColor === 'black' && piece === '‚ôô')) {
                                return true;
                            }
                        }
                    }
                }
                
                // –ö–æ–Ω–∏
                const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                for (const [rowOffset, colOffset] of knightMoves) {
                    const attackRow = row + rowOffset;
                    const attackCol = col + colOffset;
                    if (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece && this.getPieceColor(piece) === attackingColor) {
                            if (piece === '‚ôò' || piece === '‚ôû') return true;
                        }
                    }
                }
                
                // –°–ª–æ–Ω—ã –∏ —Ñ–µ—Ä–∑—å
                const bishopDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                for (const [rowDir, colDir] of bishopDirections) {
                    let attackRow = row + rowDir;
                    let attackCol = col + colDir;
                    
                    while (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece) {
                            if (this.getPieceColor(piece) === attackingColor) {
                                if (piece === '‚ôó' || piece === '‚ôù' || piece === '‚ôï' || piece === '‚ôõ') {
                                    return true;
                                }
                            }
                            break;
                        }
                        attackRow += rowDir;
                        attackCol += colDir;
                    }
                }
                
                // –õ–∞–¥—å–∏ –∏ —Ñ–µ—Ä–∑—å
                const rookDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                for (const [rowDir, colDir] of rookDirections) {
                    let attackRow = row + rowDir;
                    let attackCol = col + colDir;
                    
                    while (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece) {
                            if (this.getPieceColor(piece) === attackingColor) {
                                if (piece === '‚ôñ' || piece === '‚ôú' || piece === '‚ôï' || piece === '‚ôõ') {
                                    return true;
                                }
                            }
                            break;
                        }
                        attackRow += rowDir;
                        attackCol += colDir;
                    }
                }
                
                // –ö–æ—Ä–æ–ª—å
                const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                for (const [rowOffset, colOffset] of kingMoves) {
                    const attackRow = row + rowOffset;
                    const attackCol = col + colOffset;
                    if (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece && this.getPieceColor(piece) === attackingColor) {
                            if (piece === '‚ôî' || piece === '‚ôö') return true;
                        }
                    }
                }
                
                return false;
            }
            
            wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
                const piece = this.board[fromRow][fromCol];
                const targetPiece = this.board[toRow][toCol];
                const enPassantTarget = this.enPassantTarget;
                const capturedEnPassant = this.board[toRow][toCol] === '' && 
                                         piece === (color === 'white' ? '‚ôô' : '‚ôü') &&
                                         toCol !== fromCol;
                
                // –í—Ä–µ–º–µ–Ω–Ω—ã–π —Ö–æ–¥
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = '';
                
                if (capturedEnPassant) {
                    this.board[fromRow][toCol] = '';
                }
                
                // –ù–∞—Ö–æ–¥–∏–º –∫–æ—Ä–æ–ª—è
                let kingRow, kingCol;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = this.board[r][c];
                        if (p && this.getPieceColor(p) === color) {
                            if (p === '‚ôî' || p === '‚ôö') {
                                kingRow = r;
                                kingCol = c;
                                break;
                            }
                        }
                    }
                }
                
                const inCheck = this.isSquareAttacked(kingRow, kingCol, color);
                
                // –û—Ç–º–µ–Ω—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ö–æ–¥
                this.board[fromRow][fromCol] = piece;
                this.board[toRow][toCol] = targetPiece;
                
                if (capturedEnPassant) {
                    this.board[fromRow][toCol] = color === 'white' ? '‚ôü' : '‚ôô';
                }
                
                this.enPassantTarget = enPassantTarget;
                
                return inCheck;
            }
            
            isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            makeMove(move) {
                const piece = this.board[move.from.row][move.from.col];
                const capturedPiece = this.board[move.to.row][move.to.col];
                const pieceColor = this.getPieceColor(piece);
                
                const moveRecord = {
                    piece,
                    from: { ...move.from },
                    to: { ...move.to },
                    captured: capturedPiece,
                    enPassant: move.enPassant,
                    castle: move.castle,
                    castlingRights: JSON.parse(JSON.stringify(this.castlingRights)),
                    enPassantTarget: this.enPassantTarget,
                    halfMoveClock: this.halfMoveClock
                };
                
                if (capturedPiece || piece === '‚ôô' || piece === '‚ôü') {
                    this.halfMoveClock = 0;
                } else {
                    this.halfMoveClock++;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É
                if (piece === '‚ôî') {
                    this.castlingRights.white.kingside = false;
                    this.castlingRights.white.queenside = false;
                } else if (piece === '‚ôö') {
                    this.castlingRights.black.kingside = false;
                    this.castlingRights.black.queenside = false;
                } else if (piece === '‚ôñ') {
                    if (move.from.row === 7 && move.from.col === 0) this.castlingRights.white.queenside = false;
                    else if (move.from.row === 7 && move.from.col === 7) this.castlingRights.white.kingside = false;
                } else if (piece === '‚ôú') {
                    if (move.from.row === 0 && move.from.col === 0) this.castlingRights.black.queenside = false;
                    else if (move.from.row === 0 && move.from.col === 7) this.castlingRights.black.kingside = false;
                }
                
                // –í—ã–ø–æ–ª–Ω—è–µ–º —Ö–æ–¥
                this.board[move.to.row][move.to.col] = piece;
                this.board[move.from.row][move.from.col] = '';
                
                if (move.enPassant) {
                    const capturedRow = pieceColor === 'white' ? move.to.row + 1 : move.to.row - 1;
                    const capturedPieceEnPassant = this.board[capturedRow][move.to.col];
                    this.board[capturedRow][move.to.col] = '';
                    moveRecord.captured = capturedPieceEnPassant;
                }
                
                if (move.castle) {
                    if (move.castle === 'kingside') {
                        if (pieceColor === 'white') {
                            this.board[7][5] = this.board[7][7];
                            this.board[7][7] = '';
                        } else {
                            this.board[0][5] = this.board[0][7];
                            this.board[0][7] = '';
                        }
                    } else {
                        if (pieceColor === 'white') {
                            this.board[7][3] = this.board[7][0];
                            this.board[7][0] = '';
                        } else {
                            this.board[0][3] = this.board[0][0];
                            this.board[0][0] = '';
                        }
                    }
                }
                
                this.moveHistory.push(moveRecord);
                this.lastMove = move;
                
                if (capturedPiece) {
                    if (pieceColor === 'white') {
                        this.capturedPieces.black.push(capturedPiece);
                    } else {
                        this.capturedPieces.white.push(capturedPiece);
                    }
                }
                
                if ((piece === '‚ôô' && Math.abs(move.from.row - move.to.row) === 2) ||
                    (piece === '‚ôü' && Math.abs(move.from.row - move.to.row) === 2)) {
                    this.enPassantTarget = {
                        row: (move.from.row + move.to.row) / 2,
                        col: move.from.col
                    };
                } else {
                    this.enPassantTarget = null;
                }
                
                // –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏
                if ((piece === '‚ôô' && move.to.row === 0) || (piece === '‚ôü' && move.to.row === 7)) {
                    this.pendingPromotion = {
                        move: moveRecord,
                        color: pieceColor,
                        row: move.to.row,
                        col: move.to.col
                    };
                    this.showPromotionDialog(pieceColor);
                    return;
                }
                
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                if (this.currentPlayer === 'white') this.fullMoveNumber++;
                
                this.updateStatus();
                this.renderBoard();
                this.updateMovesList();
                this.updateMaterialDifference();
            }
            
            showPromotionDialog(color) {
                const modal = document.getElementById('promotionModal');
                const piecesContainer = document.getElementById('promotionPieces');
                piecesContainer.innerHTML = '';
                
                const pieces = color === 'white' 
                    ? ['‚ôï', '‚ôñ', '‚ôó', '‚ôò']
                    : ['‚ôõ', '‚ôú', '‚ôù', '‚ôû'];
                
                pieces.forEach(piece => {
                    const pieceDiv = document.createElement('div');
                    pieceDiv.className = `promotion-piece ${color === 'white' ? 'white-piece' : 'black-piece'}`;
                    pieceDiv.textContent = piece;
                    pieceDiv.onclick = () => this.completePromotion(piece);
                    piecesContainer.appendChild(pieceDiv);
                });
                
                modal.style.display = 'flex';
            }
            
            completePromotion(selectedPiece) {
                const modal = document.getElementById('promotionModal');
                modal.style.display = 'none';
                
                if (!this.pendingPromotion) return;
                
                const { row, col, color, move } = this.pendingPromotion;
                
                this.board[row][col] = selectedPiece;
                
                const lastMove = this.moveHistory[this.moveHistory.length - 1];
                lastMove.promotion = selectedPiece;
                
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                if (this.currentPlayer === 'white') this.fullMoveNumber++;
                
                this.pendingPromotion = null;
                
                this.updateStatus();
                this.renderBoard();
                this.updateMovesList();
                this.updateMaterialDifference();
            }
            
            async getEngineAnalysis() {
                const statusElement = document.getElementById('engineStatus');
                statusElement.textContent = 'Lichess API: –ê–Ω–∞–ª–∏–∑...';
                
                try {
                    const fen = this.boardToFen();
                    const response = await fetch(`https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}`);
                    
                    if (!response.ok) throw new Error('–û—à–∏–±–∫–∞ API');
                    
                    const data = await response.json();
                    
                    if (data && data.pvs && data.pvs[0]) {
                        const evalScore = data.pvs[0].cp ? data.pvs[0].cp / 100 : 0;
                        const evalText = evalScore > 0 ? `+${evalScore}` : evalScore;
                        statusElement.textContent = `Lichess API: –û—Ü–µ–Ω–∫–∞ ${evalText}`;
                        
                        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ª—É—á—à–∏–π —Ö–æ–¥
                        if (data.pvs[0].moves) {
                            const bestMove = data.pvs[0].moves.split(' ')[0];
                            statusElement.textContent += ` | –õ—É—á—à–∏–π —Ö–æ–¥: ${bestMove}`;
                        }
                    } else {
                        statusElement.textContent = 'Lichess API: –û—Ü–µ–Ω–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞';
                    }
                } catch (error) {
                    console.error('Lichess API error:', error);
                    statusElement.textContent = 'Lichess API: –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è';
                }
            }
            
            boardToFen() {
                let fen = '';
                for (let row = 0; row < 8; row++) {
                    let emptyCount = 0;
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece === '') {
                            emptyCount++;
                        } else {
                            if (emptyCount > 0) {
                                fen += emptyCount;
                                emptyCount = 0;
                            }
                            const fenChar = this.pieceToFen(piece);
                            fen += fenChar;
                        }
                    }
                    if (emptyCount > 0) fen += emptyCount;
                    if (row < 7) fen += '/';
                }
                fen += ` ${this.currentPlayer === 'white' ? 'w' : 'b'} - - 0 1`;
                return fen;
            }
            
            pieceToFen(piece) {
                const map = {
                    '‚ôî': 'K', '‚ôï': 'Q', '‚ôñ': 'R', '‚ôó': 'B', '‚ôò': 'N', '‚ôô': 'P',
                    '‚ôö': 'k', '‚ôõ': 'q', '‚ôú': 'r', '‚ôù': 'b', '‚ôû': 'n', '‚ôü': 'p'
                };
                return map[piece] || '';
            }
            
            updateStatus() {
                const statusElement = document.getElementById('gameStatus');
                const isCheck = this.isKingInCheck(this.currentPlayer);
                
                if (this.isCheckmate(this.currentPlayer)) {
                    statusElement.textContent = `–ú–∞—Ç! –ü–æ–±–µ–¥–∏–ª–∏ ${this.currentPlayer === 'white' ? '—á–µ—Ä–Ω—ã–µ' : '–±–µ–ª—ã–µ'}`;
                } else if (this.isStalemate(this.currentPlayer)) {
                    statusElement.textContent = '–ü–∞—Ç! –ù–∏—á—å—è';
                } else if (isCheck) {
                    statusElement.textContent = `–®–∞—Ö ${this.currentPlayer === 'white' ? '–±–µ–ª—ã–º' : '—á–µ—Ä–Ω—ã–º'}`;
                } else {
                    statusElement.textContent = `–•–æ–¥ ${this.currentPlayer === 'white' ? '–±–µ–ª—ã—Ö' : '—á–µ—Ä–Ω—ã—Ö'}`;
                }
            }
            
            isKingInCheck(color) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color) {
                            if (piece === '‚ôî' || piece === '‚ôö') {
                                return this.isSquareAttacked(row, col, color);
                            }
                        }
                    }
                }
                return false;
            }
            
            isCheckmate(color) {
                if (!this.isKingInCheck(color)) return false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color) {
                            const moves = this.getValidMoves(row, col);
                            if (moves.length > 0) return false;
                        }
                    }
                }
                return true;
            }
            
            isStalemate(color) {
                if (this.isKingInCheck(color)) return false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color) {
                            const moves = this.getValidMoves(row, col);
                            if (moves.length > 0) return false;
                        }
                    }
                }
                return true;
            }
            
            undoMove() {
                if (this.moveHistory.length === 0) return;
                
                const lastMove = this.moveHistory.pop();
                
                this.board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
                this.board[lastMove.to.row][lastMove.to.col] = lastMove.captured || '';
                
                if (lastMove.castle) {
                    if (lastMove.castle === 'kingside') {
                        if (this.getPieceColor(lastMove.piece) === 'white') {
                            this.board[7][7] = '‚ôñ';
                            this.board[7][5] = '';
                        } else {
                            this.board[0][7] = '‚ôú';
                            this.board[0][5] = '';
                        }
                    } else {
                        if (this.getPieceColor(lastMove.piece) === 'white') {
                            this.board[7][0] = '‚ôñ';
                            this.board[7][3] = '';
                        } else {
                            this.board[0][0] = '‚ôú';
                            this.board[0][3] = '';
                        }
                    }
                }
                
                if (lastMove.enPassant) {
                    const capturedRow = this.getPieceColor(lastMove.piece) === 'white' ? 
                                        lastMove.to.row + 1 : lastMove.to.row - 1;
                    this.board[capturedRow][lastMove.to.col] = 
                        this.getPieceColor(lastMove.piece) === 'white' ? '‚ôü' : '‚ôô';
                }
                
                this.castlingRights = lastMove.castlingRights;
                this.enPassantTarget = lastMove.enPassantTarget;
                this.halfMoveClock = lastMove.halfMoveClock;
                
                if (lastMove.captured) {
                    const color = this.getPieceColor(lastMove.piece) === 'white' ? 'black' : 'white';
                    const index = this.capturedPieces[color].indexOf(lastMove.captured);
                    if (index > -1) this.capturedPieces[color].splice(index, 1);
                }
                
                this.currentPlayer = this.getPieceColor(lastMove.piece);
                if (this.currentPlayer === 'white') this.fullMoveNumber--;
                
                this.lastMove = this.moveHistory[this.moveHistory.length - 1] || null;
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.pendingPromotion = null;
                
                this.updateStatus();
                this.renderBoard();
                this.updateMovesList();
                this.updateMaterialDifference();
            }
            
            resetGame() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.lastMove = null;
                this.castlingRights = {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                };
                this.enPassantTarget = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                this.pendingPromotion = null;
                
                this.updateStatus();
                this.renderBoard();
                this.updateMovesList();
                this.updateMaterialDifference();
            }
            
            flipBoard() {
                this.boardFlipped = !this.boardFlipped;
                this.renderBoard();
            }
            
            updateMovesList() {
                const movesList = document.getElementById('movesList');
                movesList.innerHTML = '';
                
                for (let i = 0; i < this.moveHistory.length; i += 2) {
                    const moveNumber = Math.floor(i / 2) + 1;
                    const moveDiv = document.createElement('div');
                    moveDiv.className = 'move-item';
                    
                    const whiteMove = this.moveHistory[i];
                    const blackMove = this.moveHistory[i + 1];
                    
                    moveDiv.innerHTML = `
                        <span class="move-number">${moveNumber}.</span>
                        <span class="move-white">${whiteMove ? this.formatMove(whiteMove) : ''}</span>
                        <span class="move-black">${blackMove ? this.formatMove(blackMove) : ''}</span>
                    `;
                    
                    movesList.appendChild(moveDiv);
                }
            }
            
            formatMove(move) {
                if (move.castle === 'kingside') return '0-0';
                if (move.castle === 'queenside') return '0-0-0';
                
                const toCol = String.fromCharCode(97 + move.to.col);
                const toRow = 8 - move.to.row;
                
                let notation = '';
                if (move.piece !== '‚ôô' && move.piece !== '‚ôü') {
                    const symbols = { '‚ôî': 'K', '‚ôï': 'Q', '‚ôñ': 'R', '‚ôó': 'B', '‚ôò': 'N' };
                    notation += symbols[move.piece] || '';
                }
                
                if (move.captured) notation += 'x';
                notation += toCol + toRow;
                
                if (move.promotion) {
                    const promoPiece = move.promotion;
                    notation += '=' + (promoPiece === '‚ôï' || promoPiece === '‚ôõ' ? 'Q' :
                                      promoPiece === '‚ôñ' || promoPiece === '‚ôú' ? 'R' :
                                      promoPiece === '‚ôó' || promoPiece === '‚ôù' ? 'B' : 'N');
                }
                
                return notation;
            }
            
            updateMaterialDifference() {
                const values = { '‚ôô': 1, '‚ôü': 1, '‚ôò': 3, '‚ôû': 3, '‚ôó': 3, '‚ôù': 3, '‚ôñ': 5, '‚ôú': 5, '‚ôï': 9, '‚ôõ': 9 };
                
                let whiteValue = 0, blackValue = 0;
                const whitePieces = [], blackPieces = [];
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            const color = this.getPieceColor(piece);
                            if (color === 'white') {
                                whiteValue += values[piece] || 0;
                                if (piece !== '‚ôî') whitePieces.push(piece);
                            } else {
                                blackValue += values[piece] || 0;
                                if (piece !== '‚ôö') blackPieces.push(piece);
                            }
                        }
                    }
                }
                
                document.getElementById('whiteMaterial').innerHTML = whitePieces.map(p => 
                    `<span class="piece-icon white-piece">${p}</span>`
                ).join('');
                
                document.getElementById('blackMaterial').innerHTML = blackPieces.map(p => 
                    `<span class="piece-icon black-piece">${p}</span>`
                ).join('');
                
                const diff = whiteValue - blackValue;
                const advantageText = document.getElementById('advantageText');
                
                if (diff > 0) {
                    advantageText.textContent = `+${diff} –≤ –ø–æ–ª—å–∑—É –±–µ–ª—ã—Ö`;
                    advantageText.className = 'advantage white';
                } else if (diff < 0) {
                    advantageText.textContent = `${diff} –≤ –ø–æ–ª—å–∑—É —á–µ—Ä–Ω—ã—Ö`;
                    advantageText.className = 'advantage black';
                } else {
                    advantageText.textContent = '–†–∞–≤–Ω–æ';
                    advantageText.className = 'advantage equal';
                }
            }
        }
        
        const chessGame = new ChessGame();
    </script>
</body>
</html>
