<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–®–∞—Ö–º–∞—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑ ‚Äî –ª–æ–∫–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –ø—Ä–∞–≤–∏–ª</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        body {
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            background: linear-gradient(145deg, #1e3a2f 0%, #132822 100%);
            min-height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .container {
            max-width: 1300px;
            width: 100%;
            background: rgba(10, 25, 20, 0.85);
            backdrop-filter: blur(4px);
            border-radius: 48px;
            padding: 30px;
            box-shadow: 0 30px 50px rgba(0, 0, 0, 0.8), inset 0 1px 3px rgba(255, 215, 0, 0.3);
            border: 1px solid #c9a96b;
        }
        h1 {
            text-align: center;
            margin: 0 0 20px 0;
            font-weight: 400;
            color: #f5e7c8;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0 #2a4a3a;
            font-size: 2.5rem;
        }
        h1 span {
            color: #ffd966;
            font-weight: 600;
        }
        .board-section {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }
        .board-wrapper {
            background: #2d4a3a;
            padding: 20px 20px 25px 20px;
            border-radius: 42px;
            box-shadow: inset 0 -6px 0 #1b3226, 0 25px 35px rgba(0, 0, 0, 0.7);
            border: 1px solid #e3b87c;
            position: relative;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 75px);
            grid-template-rows: repeat(8, 75px);
            gap: 0;
            border: 5px solid #5f4a2e;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 0 3px #a47e54;
            position: relative;
        }
        .square {
            width: 75px;
            height: 75px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 52px;
            cursor: pointer;
            transition: 0.08s ease;
            text-shadow: 2px 4px 5px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        .square.light {
            background-color: #edd6b0;
        }
        .square.dark {
            background-color: #b5885a;
        }
        .square.selected {
            background-color: #b0d9ff !important;
            box-shadow: inset 0 0 0 4px #004b8f;
        }
        .square.possible-move {
            position: relative;
        }
        .square.possible-move::after {
            content: "";
            position: absolute;
            width: 24px;
            height: 24px;
            background: rgba(0, 120, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
            border: 2px solid #a0d6a0;
            box-shadow: 0 0 10px #00aa00;
            z-index: 5;
        }
        .square.possible-capture::after {
            content: "";
            position: absolute;
            width: 60px;
            height: 60px;
            border: 5px solid rgba(180, 0, 0, 0.6);
            border-radius: 50%;
            background: rgba(255, 0, 0, 0.15);
            pointer-events: none;
            box-shadow: 0 0 15px #ff4d4d;
            z-index: 5;
        }
        .square.last-move {
            background-color: #c7e5b0 !important;
            box-shadow: inset 0 0 0 3px #2f7d2f;
        }
        .square.check {
            background-color: #ffb3b3 !important;
            box-shadow: inset 0 0 0 4px #ff0000;
        }
        .coord {
            font-size: 16px;
            color: #efe2c6;
            text-align: center;
            margin-top: 12px;
            font-weight: 600;
            letter-spacing: 4px;
        }
        .info-panel {
            flex: 1;
            min-width: 300px;
            background: #1c3d31;
            border-radius: 38px;
            padding: 25px;
            box-shadow: inset 0 -4px 0 #0e2820, 0 20px 30px rgba(0, 0, 0, 0.6);
            border: 1px solid #9eba8b;
            color: #f2f0d7;
        }
        .piece-indicator {
            font-size: 32px;
            background: #14362b;
            padding: 12px 20px;
            border-radius: 50px;
            text-align: center;
            margin: 5px 0 20px;
            border: 2px solid #e3b87c;
            box-shadow: inset 0 2px 5px #0b1f18;
            color: #ffeca2;
        }
        .eval-bar-container {
            background: #142e24;
            border-radius: 60px;
            height: 35px;
            width: 100%;
            margin: 20px 0;
            border: 3px solid #768e7a;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 3px 8px #091510;
        }
        .eval-fill {
            height: 100%;
            width: 50%;
            background: linear-gradient(90deg, #3b6e5b, #c9a96b);
            transition: width 0.3s;
        }
        .eval-text {
            font-size: 32px;
            font-weight: 800;
            text-align: center;
            margin: 15px 0;
            background: #16352a;
            padding: 15px;
            border-radius: 60px;
            border: 2px solid #edd19b;
            color: #ffeca2;
            letter-spacing: 2px;
            font-family: monospace;
        }
        .best-moves {
            background: #1a3f32;
            border-radius: 32px;
            padding: 18px;
            margin: 20px 0;
            border: 1px solid #bcaa7a;
        }
        .best-moves h3 {
            margin: 0 0 15px 0;
            color: #fad980;
            font-weight: 400;
            border-bottom: 3px solid #6e947a;
            padding-bottom: 10px;
            font-size: 22px;
        }
        .move-row {
            display: flex;
            justify-content: space-between;
            background: #124130;
            padding: 14px 22px;
            margin: 10px 0;
            border-radius: 50px;
            font-size: 22px;
            font-weight: 600;
            border: 2px solid #6f8b72;
            color: #ffeab3;
        }
        .move-row span:first-child {
            color: #cce3d4;
            font-weight: 400;
        }
        .buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 30px;
        }
        button {
            background: #2f604a;
            border: none;
            padding: 16px 22px;
            border-radius: 60px;
            font-size: 20px;
            font-weight: 600;
            color: #fbf3d7;
            cursor: pointer;
            flex: 1 1 auto;
            box-shadow: 0 8px 0 #1a3d2f, 0 6px 18px black;
            transition: 0.07s linear;
            border: 1px solid #c6ad78;
        }
        button:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #1a3d2f;
        }
        button:disabled {
            opacity: 0.4;
            transform: none;
            pointer-events: none;
        }
        .reset-btn {
            background: #735f40;
            box-shadow: 0 8px 0 #4e3e28;
            border-color: #e3b06c;
        }
        .footer {
            text-align: center;
            color: #b3cfbf;
            margin-top: 25px;
            font-size: 16px;
            font-weight: 300;
        }
        .dragging-piece {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            font-size: 52px;
            text-shadow: 2px 4px 8px black;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
<div class="container">
    <h1>‚ôõ <span>–õ–æ–∫–∞–ª—å–Ω—ã–π</span> –¥–≤–∏–∂–æ–∫ ‚Äî –≤—Å–µ –ø—Ä–∞–≤–∏–ª–∞ ‚ôö</h1>
    <div class="board-section">
        <div class="board-wrapper">
            <div class="board" id="chessboard"></div>
            <div class="coord">a  b  c  d  e  f  g  h</div>
        </div>
        <div class="info-panel">
            <div class="piece-indicator" id="pieceIndicator">‚ö™ –•–æ–¥ –±–µ–ª—ã—Ö</div>
            <div class="eval-text" id="evalDisplay">0.00</div>
            <div class="eval-bar-container">
                <div class="eval-fill" id="evalBar" style="width: 50%;"></div>
            </div>

            <div class="best-moves">
                <h3>üîç –õ—É—á—à–∏–µ —Ö–æ–¥—ã (Lichess API)</h3>
                <div id="bestMovesList">
                    <div class="move-row"><span>–ó–∞–≥—Ä—É–∑–∫–∞...</span><span></span></div>
                </div>
            </div>

            <div class="buttons">
                <button id="newGameBtn" class="reset-btn">‚ôî –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                <button id="flipBtn">üîÑ –ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å</button>
                <button id="undoBtn">‚Ü© –û—Ç–º–µ–Ω–∞</button>
            </div>
            <p style="margin: 20px 0 5px; font-size: 18px; text-align: center;">‚¨§ –∑–µ–ª—ë–Ω—ã–π ‚Äî —Ö–æ–¥, üî¥ –∫—Ä–∞—Å–Ω—ã–π ‚Äî –≤–∑—è—Ç–∏–µ</p>
            <p style="margin: 5px 0 0; font-size: 16px; text-align: center;">‚ú• –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –ø—Ä–∞–≤–∏–ª (—à–∞—Ö, –º–∞—Ç, –ø–∞—Ç, —Ä–æ–∫–∏—Ä–æ–≤–∫–∞, en passant)</p>
        </div>
    </div>
    <div class="footer">–õ–æ–∫–∞–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è ¬∑ –ø–æ–ª–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ —à–∞—Ö–º–∞—Ç ¬∑ drag-and-drop</div>
</div>

<script>
    (function() {
        // --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ---
        const startFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
        
        // --- –°–æ—Å—Ç–æ—è–Ω–∏–µ ---
        let board = [];
        let currentTurn = 'w';
        let selectedSquare = null;
        let lastMove = null;
        let flipped = false;
        let gameHistory = [];
        
        // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞
        let castlingRights = { w: { king: true, queen: true }, b: { king: true, queen: true } };
        let enPassantTarget = null; // { row, col } –∫–ª–µ—Ç–∫–∞, –Ω–∞ –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ –≤–∑—è—Ç—å –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ
        let halfMoveClock = 0;
        let fullMoveNumber = 1;
        
        // –ö—ç—à –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤
        let possibleMovesCache = new Map(); // "fromRow,fromCol" -> –º–∞—Å—Å–∏–≤ {toRow, toCol, isCapture, special}
        
        // --- Drag and drop ---
        let isDragging = false;
        let dragStartSquare = null;
        let dragElement = null;
        
        // --- DOM —ç–ª–µ–º–µ–Ω—Ç—ã ---
        const boardEl = document.getElementById('chessboard');
        const evalDisplay = document.getElementById('evalDisplay');
        const evalBar = document.getElementById('evalBar');
        const bestMovesList = document.getElementById('bestMovesList');
        const pieceIndicator = document.getElementById('pieceIndicator');
        
        // --- –£—Ç–∏–ª–∏—Ç—ã ---
        function getPieceSymbol(piece) {
            if (!piece) return '';
            const symbols = {
                k: '‚ôö', q: '‚ôõ', r: '‚ôú', b: '‚ôù', n: '‚ôû', p: '‚ôü',
                K: '‚ôî', Q: '‚ôï', R: '‚ôñ', B: '‚ôó', N: '‚ôò', P: '‚ôô'
            };
            let key = piece.type;
            if (piece.color === 'w') key = key.toUpperCase();
            return symbols[key] || '';
        }
        
        // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–æ—Å–∫–∏ –≤ FEN
        function boardToFen() {
            let fen = '';
            for (let r = 0; r < 8; r++) {
                let empty = 0;
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (!piece) {
                        empty++;
                    } else {
                        if (empty > 0) {
                            fen += empty;
                            empty = 0;
                        }
                        let pChar = piece.type;
                        if (piece.color === 'w') pChar = pChar.toUpperCase();
                        fen += pChar;
                    }
                }
                if (empty > 0) fen += empty;
                if (r < 7) fen += '/';
            }
            
            // –û—á–µ—Ä–µ–¥—å —Ö–æ–¥–∞
            fen += ' ' + currentTurn;
            
            // –†–æ–∫–∏—Ä–æ–≤–∫–∏
            let castling = '';
            if (castlingRights.w.king) castling += 'K';
            if (castlingRights.w.queen) castling += 'Q';
            if (castlingRights.b.king) castling += 'k';
            if (castlingRights.b.queen) castling += 'q';
            fen += ' ' + (castling || '-');
            
            // –í–∑—è—Ç–∏–µ –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ
            if (enPassantTarget) {
                fen += ' ' + String.fromCharCode(97 + enPassantTarget.col) + (8 - enPassantTarget.row);
            } else {
                fen += ' -';
            }
            
            // –°—á—ë—Ç—á–∏–∫–∏
            fen += ' ' + halfMoveClock + ' ' + fullMoveNumber;
            
            return fen;
        }
        
        // –ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –∏–∑ FEN
        function initBoardFromFen(fen) {
            const parts = fen.split(' ');
            const position = parts[0];
            const rows = position.split('/');
            
            // –û—á–∏—â–∞–µ–º –¥–æ—Å–∫—É
            board = [];
            for (let r = 0; r < 8; r++) {
                const row = [];
                let col = 0;
                for (let char of rows[r]) {
                    if (isNaN(char)) {
                        const color = char === char.toUpperCase() ? 'w' : 'b';
                        const type = char.toLowerCase();
                        row[col] = { type, color };
                        col++;
                    } else {
                        let empty = parseInt(char, 10);
                        for (let i = 0; i < empty; i++) {
                            row[col] = null;
                            col++;
                        }
                    }
                }
                board.push(row);
            }
            
            // –û—á–µ—Ä–µ–¥—å —Ö–æ–¥–∞
            currentTurn = parts[1] || 'w';
            
            // –†–æ–∫–∏—Ä–æ–≤–∫–∏
            castlingRights = { w: { king: false, queen: false }, b: { king: false, queen: false } };
            if (parts[2] && parts[2] !== '-') {
                if (parts[2].includes('K')) castlingRights.w.king = true;
                if (parts[2].includes('Q')) castlingRights.w.queen = true;
                if (parts[2].includes('k')) castlingRights.b.king = true;
                if (parts[2].includes('q')) castlingRights.b.queen = true;
            }
            
            // –í–∑—è—Ç–∏–µ –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ
            if (parts[3] && parts[3] !== '-') {
                const col = parts[3].charCodeAt(0) - 97;
                const row = 8 - parseInt(parts[3][1]);
                enPassantTarget = { row, col };
            } else {
                enPassantTarget = null;
            }
            
            // –°—á—ë—Ç—á–∏–∫–∏
            halfMoveClock = parts[4] ? parseInt(parts[4]) : 0;
            fullMoveNumber = parts[5] ? parseInt(parts[5]) : 1;
            
            selectedSquare = null;
            possibleMovesCache.clear();
        }
        
        // --- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤ (–±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ —à–∞—Ö–∞) ---
        function generatePseudoMoves(forColor) {
            const moves = [];
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.color !== forColor) continue;
                    
                    const type = piece.type;
                    
                    // –ü–µ—à–∫–∞
                    if (type === 'p') {
                        const direction = piece.color === 'w' ? -1 : 1;
                        const startRow = piece.color === 'w' ? 6 : 1;
                        
                        // –î–≤–∏–∂–µ–Ω–∏–µ –≤–ø–µ—Ä—ë–¥
                        if (r + direction >= 0 && r + direction < 8 && !board[r + direction][c]) {
                            moves.push({
                                fromRow: r, fromCol: c,
                                toRow: r + direction, toCol: c,
                                isCapture: false,
                                piece: piece
                            });
                            
                            // –î–≤–æ–π–Ω–æ–π —Ö–æ–¥
                            if (r === startRow && !board[r + 2*direction][c]) {
                                moves.push({
                                    fromRow: r, fromCol: c,
                                    toRow: r + 2*direction, toCol: c,
                                    isCapture: false,
                                    piece: piece,
                                    doublePawn: true
                                });
                            }
                        }
                        
                        // –í–∑—è—Ç–∏—è
                        for (let dc of [-1, 1]) {
                            const newCol = c + dc;
                            if (newCol >= 0 && newCol < 8 && r + direction >= 0 && r + direction < 8) {
                                // –û–±—ã—á–Ω–æ–µ –≤–∑—è—Ç–∏–µ
                                if (board[r + direction][newCol] && board[r + direction][newCol].color !== piece.color) {
                                    moves.push({
                                        fromRow: r, fromCol: c,
                                        toRow: r + direction, toCol: newCol,
                                        isCapture: true,
                                        piece: piece
                                    });
                                }
                                // –í–∑—è—Ç–∏–µ –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ
                                if (enPassantTarget && enPassantTarget.row === r + direction && enPassantTarget.col === newCol) {
                                    moves.push({
                                        fromRow: r, fromCol: c,
                                        toRow: r + direction, toCol: newCol,
                                        isCapture: true,
                                        piece: piece,
                                        enPassant: true
                                    });
                                }
                            }
                        }
                    }
                    
                    // –ö–æ–Ω—å
                    if (type === 'n') {
                        const knightMoves = [
                            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                            [1, -2], [1, 2], [2, -1], [2, 1]
                        ];
                        
                        for (let [dr, dc] of knightMoves) {
                            const newRow = r + dr;
                            const newCol = c + dc;
                            if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                                if (!board[newRow][newCol] || board[newRow][newCol].color !== piece.color) {
                                    moves.push({
                                        fromRow: r, fromCol: c,
                                        toRow: newRow, toCol: newCol,
                                        isCapture: !!board[newRow][newCol],
                                        piece: piece
                                    });
                                }
                            }
                        }
                    }
                    
                    // –°–ª–æ–Ω
                    if (type === 'b') {
                        const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                        
                        for (let [dr, dc] of directions) {
                            for (let step = 1; step < 8; step++) {
                                const newRow = r + dr * step;
                                const newCol = c + dc * step;
                                if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                                
                                if (!board[newRow][newCol]) {
                                    moves.push({
                                        fromRow: r, fromCol: c,
                                        toRow: newRow, toCol: newCol,
                                        isCapture: false,
                                        piece: piece
                                    });
                                } else {
                                    if (board[newRow][newCol].color !== piece.color) {
                                        moves.push({
                                            fromRow: r, fromCol: c,
                                            toRow: newRow, toCol: newCol,
                                            isCapture: true,
                                            piece: piece
                                        });
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    
                    // –õ–∞–¥—å—è
                    if (type === 'r') {
                        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                        
                        for (let [dr, dc] of directions) {
                            for (let step = 1; step < 8; step++) {
                                const newRow = r + dr * step;
                                const newCol = c + dc * step;
                                if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                                
                                if (!board[newRow][newCol]) {
                                    moves.push({
                                        fromRow: r, fromCol: c,
                                        toRow: newRow, toCol: newCol,
                                        isCapture: false,
                                        piece: piece
                                    });
                                } else {
                                    if (board[newRow][newCol].color !== piece.color) {
                                        moves.push({
                                            fromRow: r, fromCol: c,
                                            toRow: newRow, toCol: newCol,
                                            isCapture: true,
                                            piece: piece
                                        });
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    
                    // –§–µ—Ä–∑—å (–∫–æ–º–±–∏–Ω–∞—Ü–∏—è —Å–ª–æ–Ω–∞ –∏ –ª–∞–¥—å–∏)
                    if (type === 'q') {
                        const directions = [
                            [-1, -1], [-1, 1], [1, -1], [1, 1],
                            [-1, 0], [1, 0], [0, -1], [0, 1]
                        ];
                        
                        for (let [dr, dc] of directions) {
                            for (let step = 1; step < 8; step++) {
                                const newRow = r + dr * step;
                                const newCol = c + dc * step;
                                if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                                
                                if (!board[newRow][newCol]) {
                                    moves.push({
                                        fromRow: r, fromCol: c,
                                        toRow: newRow, toCol: newCol,
                                        isCapture: false,
                                        piece: piece
                                    });
                                } else {
                                    if (board[newRow][newCol].color !== piece.color) {
                                        moves.push({
                                            fromRow: r, fromCol: c,
                                            toRow: newRow, toCol: newCol,
                                            isCapture: true,
                                            piece: piece
                                        });
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    
                    // –ö–æ—Ä–æ–ª—å
                    if (type === 'k') {
                        const kingMoves = [
                            [-1, -1], [-1, 0], [-1, 1],
                            [0, -1], [0, 1],
                            [1, -1], [1, 0], [1, 1]
                        ];
                        
                        for (let [dr, dc] of kingMoves) {
                            const newRow = r + dr;
                            const newCol = c + dc;
                            if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                                if (!board[newRow][newCol] || board[newRow][newCol].color !== piece.color) {
                                    moves.push({
                                        fromRow: r, fromCol: c,
                                        toRow: newRow, toCol: newCol,
                                        isCapture: !!board[newRow][newCol],
                                        piece: piece
                                    });
                                }
                            }
                        }
                        
                        // –†–æ–∫–∏—Ä–æ–≤–∫–∞
                        if (!isInCheck(piece.color)) {
                            const backRank = piece.color === 'w' ? 7 : 0;
                            
                            // –ö–æ—Ä–æ—Ç–∫–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞
                            if (castlingRights[piece.color].king) {
                                if (!board[backRank][5] && !board[backRank][6]) {
                                    if (!isSquareAttacked(backRank, 5, piece.color) && !isSquareAttacked(backRank, 6, piece.color)) {
                                        moves.push({
                                            fromRow: r, fromCol: c,
                                            toRow: backRank, toCol: 6,
                                            isCapture: false,
                                            piece: piece,
                                            castle: 'king'
                                        });
                                    }
                                }
                            }
                            
                            // –î–ª–∏–Ω–Ω–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞
                            if (castlingRights[piece.color].queen) {
                                if (!board[backRank][3] && !board[backRank][2] && !board[backRank][1]) {
                                    if (!isSquareAttacked(backRank, 3, piece.color) && !isSquareAttacked(backRank, 2, piece.color)) {
                                        moves.push({
                                            fromRow: r, fromCol: c,
                                            toRow: backRank, toCol: 2,
                                            isCapture: false,
                                            piece: piece,
                                            castle: 'queen'
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return moves;
        }
        
        // --- –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∫–æ—Ä–æ–ª—å –ø–æ–¥ —à–∞—Ö–æ–º ---
        function isInCheck(color) {
            // –ù–∞–π—Ç–∏ –∫–æ—Ä–æ–ª—è
            let kingRow = -1, kingCol = -1;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.type === 'k' && piece.color === color) {
                        kingRow = r;
                        kingCol = c;
                        break;
                    }
                }
            }
            
            if (kingRow === -1) return true; // –ö–æ—Ä–æ–ª—è –Ω–µ—Ç (–Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ)
            
            return isSquareAttacked(kingRow, kingCol, color);
        }
        
        // --- –ü—Ä–æ–≤–µ—Ä–∫–∞, –∞—Ç–∞–∫–æ–≤–∞–Ω–∞ –ª–∏ –∫–ª–µ—Ç–∫–∞ ---
        function isSquareAttacked(row, col, defendingColor) {
            const attackingColor = defendingColor === 'w' ? 'b' : 'w';
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Ç–∞–∫ –ø–µ—à–µ–∫
            const pawnDir = defendingColor === 'w' ? -1 : 1;
            for (let dc of [-1, 1]) {
                const newRow = row + pawnDir;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const piece = board[newRow][newCol];
                    if (piece && piece.type === 'p' && piece.color === attackingColor) return true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Ç–∞–∫ –∫–æ–Ω–µ–π
            const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
            for (let [dr, dc] of knightMoves) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const piece = board[newRow][newCol];
                    if (piece && piece.type === 'n' && piece.color === attackingColor) return true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Ç–∞–∫ —Å–ª–æ–Ω–æ–≤ –∏ —Ñ–µ—Ä–∑–µ–π (–¥–∏–∞–≥–æ–Ω–∞–ª–∏)
            const bishopDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
            for (let [dr, dc] of bishopDirs) {
                for (let step = 1; step < 8; step++) {
                    const newRow = row + dr * step;
                    const newCol = col + dc * step;
                    if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                    
                    const piece = board[newRow][newCol];
                    if (piece) {
                        if (piece.color === attackingColor && (piece.type === 'b' || piece.type === 'q')) return true;
                        break;
                    }
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Ç–∞–∫ –ª–∞–¥–µ–π –∏ —Ñ–µ—Ä–∑–µ–π (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏/–≤–µ—Ä—Ç–∏–∫–∞–ª–∏)
            const rookDirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (let [dr, dc] of rookDirs) {
                for (let step = 1; step < 8; step++) {
                    const newRow = row + dr * step;
                    const newCol = col + dc * step;
                    if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                    
                    const piece = board[newRow][newCol];
                    if (piece) {
                        if (piece.color === attackingColor && (piece.type === 'r' || piece.type === 'q')) return true;
                        break;
                    }
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Ç–∞–∫ –∫–æ—Ä–æ–ª—è
            const kingMoves = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, -1], [1, 0], [1, 1]
            ];
            for (let [dr, dc] of kingMoves) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const piece = board[newRow][newCol];
                    if (piece && piece.type === 'k' && piece.color === attackingColor) return true;
                }
            }
            
            return false;
        }
        
        // --- –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ª–µ–≥–∞–ª—å–Ω—ã—Ö —Ö–æ–¥–æ–≤ (—Å —É—á—ë—Ç–æ–º —à–∞—Ö–∞) ---
        function generateLegalMoves(forColor) {
            const pseudoMoves = generatePseudoMoves(forColor);
            const legalMoves = [];
            
            for (let move of pseudoMoves) {
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                const piece = board[move.fromRow][move.fromCol];
                const targetPiece = board[move.toRow][move.toCol];
                const oldCastling = JSON.parse(JSON.stringify(castlingRights));
                const oldEnPassant = enPassantTarget ? { ...enPassantTarget } : null;
                
                // –í—ã–ø–æ–ª–Ω—è–µ–º —Ö–æ–¥
                board[move.toRow][move.toCol] = piece;
                board[move.fromRow][move.fromCol] = null;
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Ö–æ–¥–æ–≤
                if (move.enPassant) {
                    // –£–±–∏—Ä–∞–µ–º –≤–∑—è—Ç—É—é –ø–µ—à–∫—É
                    const capturedRow = move.fromRow;
                    const capturedCol = move.toCol;
                    board[capturedRow][capturedCol] = null;
                }
                
                if (move.castle) {
                    // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –ª–∞–¥—å—é
                    const backRank = piece.color === 'w' ? 7 : 0;
                    if (move.castle === 'king') {
                        board[backRank][5] = board[backRank][7]; // –õ–∞–¥—å—è —Å h1/h8 –Ω–∞ f1/f8
                        board[backRank][7] = null;
                    } else {
                        board[backRank][3] = board[backRank][0]; // –õ–∞–¥—å—è —Å a1/a8 –Ω–∞ d1/d8
                        board[backRank][0] = null;
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ–¥ —à–∞—Ö–æ–º –ª–∏ –∫–æ—Ä–æ–ª—å –ø–æ—Å–ª–µ —Ö–æ–¥–∞
                const kingInCheck = isInCheck(forColor);
                
                // –û—Ç–∫–∞—Ç—ã–≤–∞–µ–º —Ö–æ–¥
                board[move.fromRow][move.fromCol] = piece;
                board[move.toRow][move.toCol] = targetPiece;
                
                if (move.enPassant) {
                    const capturedRow = move.fromRow;
                    const capturedCol = move.toCol;
                    const capturedPiece = { type: 'p', color: forColor === 'w' ? 'b' : 'w' };
                    board[capturedRow][capturedCol] = capturedPiece;
                }
                
                if (move.castle) {
                    const backRank = piece.color === 'w' ? 7 : 0;
                    if (move.castle === 'king') {
                        board[backRank][7] = board[backRank][5];
                        board[backRank][5] = null;
                    } else {
                        board[backRank][0] = board[backRank][3];
                        board[backRank][3] = null;
                    }
                }
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–∞–≤–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫–∏ –∏ en passant
                castlingRights = oldCastling;
                enPassantTarget = oldEnPassant;
                
                if (!kingInCheck) {
                    legalMoves.push(move);
                }
            }
            
            return legalMoves;
        }
        
        // --- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤ ---
        function updatePossibleMoves() {
            possibleMovesCache.clear();
            const moves = generateLegalMoves(currentTurn);
            
            for (let move of moves) {
                const key = `${move.fromRow},${move.fromCol}`;
                if (!possibleMovesCache.has(key)) {
                    possibleMovesCache.set(key, []);
                }
                possibleMovesCache.get(key).push({
                    toRow: move.toRow,
                    toCol: move.toCol,
                    isCapture: move.isCapture
                });
            }
        }
        
        // --- –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ö–æ–¥–∞ ---
        function makeMove(fromRow, fromCol, toRow, toCol) {
            // –ù–∞—Ö–æ–¥–∏–º —Ö–æ–¥ –≤ –∫—ç—à–µ
            const key = `${fromRow},${fromCol}`;
            if (!possibleMovesCache.has(key)) return false;
            
            const moves = possibleMovesCache.get(key);
            const move = moves.find(m => m.toRow === toRow && m.toCol === toCol);
            if (!move) return false;
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ç–æ—Ä–∏—é
            gameHistory.push(boardToFen());
            
            // –í—ã–ø–æ–ª–Ω—è–µ–º —Ö–æ–¥
            const piece = board[fromRow][fromCol];
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∞–≤–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫–∏
            if (piece.type === 'k') {
                if (piece.color === 'w') {
                    castlingRights.w.king = false;
                    castlingRights.w.queen = false;
                } else {
                    castlingRights.b.king = false;
                    castlingRights.b.queen = false;
                }
            }
            
            if (piece.type === 'r') {
                if (piece.color === 'w') {
                    if (fromRow === 7 && fromCol === 7) castlingRights.w.king = false;
                    if (fromRow === 7 && fromCol === 0) castlingRights.w.queen = false;
                } else {
                    if (fromRow === 0 && fromCol === 7) castlingRights.b.king = false;
                    if (fromRow === 0 && fromCol === 0) castlingRights.b.queen = false;
                }
            }
            
            // –ï—Å–ª–∏ –≤–∑—è–ª–∏ –ª–∞–¥—å—é
            const targetPiece = board[toRow][toCol];
            if (targetPiece && targetPiece.type === 'r') {
                if (targetPiece.color === 'w') {
                    if (toRow === 7 && toCol === 7) castlingRights.w.king = false;
                    if (toRow === 7 && toCol === 0) castlingRights.w.queen = false;
                } else {
                    if (toRow === 0 && toCol === 7) castlingRights.b.king = false;
                    if (toRow === 0 && toCol === 0) castlingRights.b.queen = false;
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ en passant target
            enPassantTarget = null;
            if (piece.type === 'p' && Math.abs(toRow - fromRow) === 2) {
                // –î–≤–æ–π–Ω–æ–π —Ö–æ–¥ –ø–µ—à–∫–∏ - —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–µ–ª—å –¥–ª—è en passant
                const epRow = (fromRow + toRow) / 2;
                enPassantTarget = { row: epRow, col: fromCol };
            }
            
            // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ–∏–≥—É—Ä—É
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∑—è—Ç–∏—è –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ
            if (move.isCapture && piece.type === 'p' && toCol !== fromCol && !targetPiece) {
                // –£–±–∏—Ä–∞–µ–º –ø–µ—à–∫—É, –≤–∑—è—Ç—É—é –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ
                board[fromRow][toCol] = null;
            }
            
            // –†–æ–∫–∏—Ä–æ–≤–∫–∞
            if (piece.type === 'k' && Math.abs(toCol - fromCol) === 2) {
                const backRank = piece.color === 'w' ? 7 : 0;
                if (toCol === 6) {
                    // –ö–æ—Ä–æ—Ç–∫–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞
                    board[backRank][5] = board[backRank][7];
                    board[backRank][7] = null;
                } else if (toCol === 2) {
                    // –î–ª–∏–Ω–Ω–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞
                    board[backRank][3] = board[backRank][0];
                    board[backRank][0] = null;
                }
            }
            
            // –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏
            if (piece.type === 'p' && (toRow === 0 || toRow === 7)) {
                board[toRow][toCol] = { type: 'q', color: piece.color };
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ lastMove
            lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
            
            // –°–º–µ–Ω–∞ –æ—á–µ—Ä–µ–¥–∏
            currentTurn = currentTurn === 'w' ? 'b' : 'w';
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á—ë—Ç—á–∏–∫–æ–≤
            if (piece.type === 'p' || move.isCapture) {
                halfMoveClock = 0;
            } else {
                halfMoveClock++;
            }
            
            if (currentTurn === 'w') {
                fullMoveNumber++;
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤
            updatePossibleMoves();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∞—Ç/–ø–∞—Ç
            const moves = generateLegalMoves(currentTurn);
            if (moves.length === 0) {
                if (isInCheck(currentTurn)) {
                    console.log('–ú–∞—Ç!');
                } else {
                    console.log('–ü–∞—Ç!');
                }
            }
            
            return true;
        }
        
        // --- –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥–æ—Å–∫–∏ ---
        function renderBoard() {
            boardEl.innerHTML = '';
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à –ø–µ—Ä–µ–¥ –æ—Ç—Ä–∏—Å–æ–≤–∫–æ–π
            updatePossibleMoves();
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const row = flipped ? 7 - r : r;
                    const col = flipped ? 7 - c : c;
                    const piece = board[row][col];
                    const isLight = (row + col) % 2 === 0;
                    
                    const squareDiv = document.createElement('div');
                    squareDiv.className = `square ${isLight ? 'light' : 'dark'}`;
                    squareDiv.dataset.row = row;
                    squareDiv.dataset.col = col;
                    
                    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–ª–µ—Ç–∫–∏
                    if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                        squareDiv.classList.add('selected');
                    }
                    
                    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ö–æ–¥–∞
                    if (lastMove) {
                        if ((lastMove.from.row === row && lastMove.from.col === col) ||
                            (lastMove.to.row === row && lastMove.to.col === col)) {
                            squareDiv.classList.add('last-move');
                        }
                    }
                    
                    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —à–∞—Ö–∞
                    if (piece && piece.type === 'k' && piece.color === currentTurn && isInCheck(currentTurn)) {
                        squareDiv.classList.add('check');
                    }
                    
                    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ö–æ–¥–æ–≤ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Ñ–∏–≥—É—Ä—ã
                    if (selectedSquare && !(selectedSquare.row === row && selectedSquare.col === col)) {
                        const key = `${selectedSquare.row},${selectedSquare.col}`;
                        if (possibleMovesCache.has(key)) {
                            const moves = possibleMovesCache.get(key);
                            const move = moves.find(m => m.toRow === row && m.toCol === col);
                            if (move) {
                                if (move.isCapture) {
                                    squareDiv.classList.add('possible-capture');
                                } else {
                                    squareDiv.classList.add('possible-move');
                                }
                            }
                        }
                    }
                    
                    if (piece) {
                        squareDiv.textContent = getPieceSymbol(piece);
                    }
                    
                    // –°–æ–±—ã—Ç–∏—è
                    squareDiv.addEventListener('mousedown', onMouseDown);
                    squareDiv.addEventListener('click', onClick);
                    
                    boardEl.appendChild(squareDiv);
                }
            }
            
            pieceIndicator.innerHTML = currentTurn === 'w' ? '‚ôî –•–æ–¥ –±–µ–ª—ã—Ö' : '‚ôö –•–æ–¥ —á—ë—Ä–Ω—ã—Ö';
        }
        
        // --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ ---
        function onClick(e) {
            const row = parseInt(e.currentTarget.dataset.row);
            const col = parseInt(e.currentTarget.dataset.col);
            const piece = board[row][col];
            
            // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ
            if (selectedSquare === null) {
                if (piece && piece.color === currentTurn) {
                    selectedSquare = { row, col };
                    renderBoard();
                }
                return;
            }
            
            // –£–∂–µ –µ—Å—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–∞—è —Ñ–∏–≥—É—Ä–∞
            const from = selectedSquare;
            
            // –ö–ª–∏–∫ –Ω–∞ —Ç—É –∂–µ –∫–ª–µ—Ç–∫—É
            if (from.row === row && from.col === col) {
                selectedSquare = null;
                renderBoard();
                return;
            }
            
            // –ü–æ–ø—ã—Ç–∫–∞ —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥
            const success = makeMove(from.row, from.col, row, col);
            if (success) {
                selectedSquare = null;
                renderBoard();
                fetchLichessAnalysis();
            } else {
                selectedSquare = null;
                renderBoard();
            }
        }
        
        // --- Drag and drop ---
        function onMouseDown(e) {
            const square = e.currentTarget;
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            const piece = board[row][col];
            
            if (!piece || piece.color !== currentTurn) return;
            
            e.preventDefault();
            isDragging = true;
            dragStartSquare = { row, col };
            
            // –°–æ–∑–¥–∞—ë–º —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
            dragElement = document.createElement('div');
            dragElement.className = 'dragging-piece';
            dragElement.textContent = getPieceSymbol(piece);
            document.body.appendChild(dragElement);
            
            updateDragPosition(e.clientX, e.clientY);
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—É—é —Ñ–∏–≥—É—Ä—É
            selectedSquare = { row, col };
            renderBoard();
        }
        
        function onMouseMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            updateDragPosition(e.clientX, e.clientY);
        }
        
        function onMouseUp(e) {
            if (!isDragging || !dragStartSquare) return;
            
            const targetElement = document.elementFromPoint(e.clientX, e.clientY);
            const targetSquare = targetElement?.closest('.square');
            
            if (targetSquare && dragStartSquare) {
                const toRow = parseInt(targetSquare.dataset.row);
                const toCol = parseInt(targetSquare.dataset.col);
                const fromRow = dragStartSquare.row;
                const fromCol = dragStartSquare.col;
                
                const success = makeMove(fromRow, fromCol, toRow, toCol);
                if (success) {
                    fetchLichessAnalysis();
                }
            }
            
            // –û—á–∏—Å—Ç–∫–∞
            if (dragElement) {
                dragElement.remove();
                dragElement = null;
            }
            isDragging = false;
            dragStartSquare = null;
            selectedSquare = null;
            
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            
            renderBoard();
        }
        
        function updateDragPosition(x, y) {
            if (dragElement) {
                dragElement.style.left = x + 'px';
                dragElement.style.top = y + 'px';
            }
        }
        
        // --- Lichess API –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—Ü–µ–Ω–∫–∏) ---
        async function fetchLichessAnalysis() {
            const fen = boardToFen();
            const url = `https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}&multiPv=5`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (!data || !data.pvs || data.pvs.length === 0) {
                    evalDisplay.innerText = '‚Äî';
                    bestMovesList.innerHTML = '<div class="move-row"><span>–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</span><span></span></div>';
                    return;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ü–µ–Ω–∫—É
                const pv0 = data.pvs[0];
                let cp = pv0.cp;
                let mate = pv0.mate;
                let evalText = '';
                
                if (mate !== undefined) {
                    evalText = `#${mate}`;
                } else if (cp !== undefined) {
                    evalText = (cp / 100).toFixed(2);
                }
                evalDisplay.innerText = evalText;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞—Ä
                let barWidth = 50;
                if (mate !== undefined) {
                    barWidth = mate > 0 ? 100 : 0;
                } else if (cp !== undefined) {
                    let evalNorm = Math.max(-5, Math.min(5, cp / 100));
                    barWidth = 50 + evalNorm * 10;
                    if (barWidth < 0) barWidth = 0;
                    if (barWidth > 100) barWidth = 100;
                }
                evalBar.style.width = barWidth + '%';
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ª—É—á—à–∏—Ö —Ö–æ–¥–æ–≤
                let htmlStr = '';
                data.pvs.slice(0, 5).forEach((pv, idx) => {
                    const firstUci = pv.moves ? pv.moves.split(' ')[0] : '';
                    let moveStr = firstUci;
                    if (moveStr.length >= 4) {
                        moveStr = moveStr.slice(0,2) + ' ‚Üí ' + moveStr.slice(2,4);
                    }
                    let score = '';
                    if (pv.mate) score = '#' + pv.mate;
                    else if (pv.cp) score = (pv.cp/100).toFixed(2);
                    htmlStr += `<div class="move-row"><span>${moveStr}</span><span>${score}</span></div>`;
                });
                bestMovesList.innerHTML = htmlStr;
                
            } catch (error) {
                console.warn('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞–Ω–∞–ª–∏–∑–∞:', error);
            }
        }
        
        // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–π ---
        function newGame() {
            initBoardFromFen(startFen);
            lastMove = null;
            gameHistory = [];
            selectedSquare = null;
            possibleMovesCache.clear();
            renderBoard();
            fetchLichessAnalysis();
        }
        
        function undoMove() {
            if (gameHistory.length === 0) {
                alert('–ù–µ—Ç —Ö–æ–¥–æ–≤ –¥–ª—è –æ—Ç–º–µ–Ω—ã');
                return;
            }
            const prevFen = gameHistory.pop();
            initBoardFromFen(prevFen);
            lastMove = null;
            selectedSquare = null;
            renderBoard();
            fetchLichessAnalysis();
        }
        
        function flipBoard() {
            flipped = !flipped;
            renderBoard();
        }
        
        // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---
        initBoardFromFen(startFen);
        renderBoard();
        fetchLichessAnalysis();
        
        // –ö–Ω–æ–ø–∫–∏
        document.getElementById('newGameBtn').addEventListener('click', newGame);
        document.getElementById('flipBtn').addEventListener('click', flipBoard);
        document.getElementById('undoBtn').addEventListener('click', undoMove);
        
        // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π drag
        document.addEventListener('dragstart', (e) => e.preventDefault());
    })();
</script>
</body>
</html>
