<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Шахматный анализатор</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #b58863;
        }
        
        .main-content {
            display: flex;
            gap: 20px;
            height: calc(100vh - 120px);
        }
        
        .board-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .board-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 2px solid #404040;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .square.light {
            background-color: #f0d9b5;
        }
        
        .square.dark {
            background-color: #b58863;
        }
        
        .square.selected {
            background-color: rgba(106, 190, 255, 0.7);
        }
        
        .square.last-move {
            background-color: rgba(255, 255, 0, 0.4);
        }
        
        .square.check {
            background-color: rgba(255, 0, 0, 0.5);
        }
        
        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        .square.valid-capture::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            border: 4px solid rgba(0, 0, 0, 0.3);
            box-sizing: border-box;
        }
        
        .piece {
            width: 85%;
            height: 85%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: grab;
            z-index: 10;
            transition: transform 0.2s;
            font-size: 42px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .piece.dragging {
            cursor: grabbing;
            transform: scale(1.1);
            z-index: 100;
        }
        
        .coordinates {
            position: absolute;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }
        
        .coordinate-file {
            bottom: -20px;
            width: 100%;
            text-align: center;
        }
        
        .coordinate-rank {
            left: -20px;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            text-align: center;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background: #404040;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .control-btn:hover {
            background: #505050;
        }
        
        .control-btn.active {
            background: #b58863;
        }
        
        .panel-section {
            width: 300px;
            display: flex;
            flex-direction: column;
        }
        
        .moves-panel {
            background: #2c2c2c;
            border-radius: 8px;
            padding: 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        .moves-list {
            flex: 1;
            overflow-y: auto;
            max-height: 400px;
        }
        
        .moves-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .moves-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .moves-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .move-row {
            display: flex;
            padding: 8px 10px;
            border-radius: 4px;
            margin-bottom: 2px;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        
        .move-row:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .move-row.active {
            background-color: rgba(181, 136, 99, 0.3);
        }
        
        .move-number {
            width: 30px;
            color: #888;
        }
        
        .move-white, .move-black {
            flex: 1;
            padding: 0 10px;
        }
        
        .status-bar {
            margin-top: 15px;
            padding: 10px;
            background: #2c2c2c;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }
        
        .status-check {
            color: #ff9900;
            font-weight: bold;
        }
        
        .status-mate {
            color: #ff4d4d;
            font-weight: bold;
        }
        
        .status-stalemate {
            color: #4dffb8;
            font-weight: bold;
        }
        
        .status-draw {
            color: #4db8ff;
            font-weight: bold;
        }
        
        .evaluation-bar {
            width: 20px;
            background: #2c2c2c;
            border-radius: 4px;
            margin-right: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .evaluation-fill {
            position: absolute;
            width: 100%;
            background: #f0d9b5;
            transition: height 0.3s;
        }
        
        .evaluation-text {
            font-size: 12px;
            color: #fff;
            position: absolute;
            width: 100%;
            text-align: center;
        }
        
        @media (max-width: 900px) {
            .main-content {
                flex-direction: column;
                height: auto;
            }
            
            .panel-section {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">ШАХМАТНЫЙ АНАЛИЗАТОР</div>
            <div class="controls">
                <button class="control-btn" id="flipBoard">Перевернуть доску</button>
                <button class="control-btn" id="newGame">Новая игра</button>
                <button class="control-btn" id="undoMove">←</button>
                <button class="control-btn" id="redoMove">→</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="board-section">
                <div class="board-container">
                    <div class="board" id="chessboard">
                        <!-- Шахматная доска будет сгенерирована JavaScript -->
                    </div>
                    <div class="coordinates" id="coordinates"></div>
                </div>
                
                <div class="status-bar" id="statusBar">
                    Ход белых. Начните игру!
                </div>
            </div>
            
            <div class="panel-section">
                <div class="moves-panel">
                    <div class="panel-header">
                        <h3>Ходы</h3>
                        <div>Всего: <span id="moveCount">0</span></div>
                    </div>
                    <div class="moves-list" id="movesList">
                        <!-- Список ходов будет сгенерирован JavaScript -->
                    </div>
                </div>
                
                <div class="evaluation-bar">
                    <div class="evaluation-fill" id="evaluationFill" style="height: 50%;"></div>
                    <div class="evaluation-text" id="evaluationText">0.0</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Основные константы и переменные
        const FILES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        const RANKS = ['1', '2', '3', '4', '5', '6', '7', '8'];
        
        let boardState = [];
        let currentPlayer = 'white';
        let selectedSquare = null;
        let validMoves = [];
        let moveHistory = [];
        let positionHistory = [];
        let halfMoveClock = 0; // для правила 50 ходов
        let fullMoveNumber = 1;
        let boardFlipped = false;
        let gameStatus = 'active'; // active, check, checkmate, stalemate, draw
        let currentMoveIndex = -1;
        
        // Инициализация доски
        function initializeBoard() {
            const board = document.getElementById('chessboard');
            const coordinates = document.getElementById('coordinates');
            board.innerHTML = '';
            coordinates.innerHTML = '';
            
            // Создаем координаты
            for (let i = 0; i < 8; i++) {
                const fileCoord = document.createElement('div');
                fileCoord.className = 'coordinates coordinate-file';
                fileCoord.style.gridColumn = i + 1;
                fileCoord.textContent = FILES[boardFlipped ? 7-i : i];
                coordinates.appendChild(fileCoord);
                
                const rankCoord = document.createElement('div');
                rankCoord.className = 'coordinates coordinate-rank';
                rankCoord.style.gridRow = i + 1;
                rankCoord.textContent = RANKS[boardFlipped ? i : 7-i];
                coordinates.appendChild(rankCoord);
            }
            
            // Создаем клетки доски
            for (let rank = 0; rank < 8; rank++) {
                boardState[rank] = [];
                for (let file = 0; file < 8; file++) {
                    const square = document.createElement('div');
                    const displayRank = boardFlipped ? 7 - rank : rank;
                    const displayFile = boardFlipped ? 7 - file : file;
                    
                    square.className = `square ${(rank + file) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.rank = displayRank;
                    square.dataset.file = displayFile;
                    square.dataset.position = `${FILES[displayFile]}${RANKS[displayRank]}`;
                    
                    square.addEventListener('click', handleSquareClick);
                    
                    // Добавляем обработчики для drag and drop
                    square.addEventListener('dragover', handleDragOver);
                    square.addEventListener('drop', handleDrop);
                    
                    board.appendChild(square);
                    boardState[rank][file] = null;
                }
            }
            
            setupPieces();
            updateStatusBar();
        }
        
        // Расстановка фигур на доске
        function setupPieces() {
            // Очищаем доску
            for (let rank = 0; rank < 8; rank++) {
                for (let file = 0; file < 8; file++) {
                    const square = getSquareElement(rank, file);
                    if (square) {
                        // Удаляем все фигуры
                        const piece = square.querySelector('.piece');
                        if (piece) {
                            square.removeChild(piece);
                        }
                        boardState[rank][file] = null;
                    }
                }
            }
            
            // Расставляем пешки
            for (let file = 0; file < 8; file++) {
                placePiece(1, file, 'pawn', 'black');
                placePiece(6, file, 'pawn', 'white');
            }
            
            // Расставляем остальные фигуры
            const backRankPieces = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let file = 0; file < 8; file++) {
                placePiece(0, file, backRankPieces[file], 'black');
                placePiece(7, file, backRankPieces[file], 'white');
            }
            
            // Сохраняем начальную позицию
            savePositionToHistory();
            currentMoveIndex = 0;
        }
        
        // Размещение фигуры на доске
        function placePiece(rank, file, type, color) {
            const square = getSquareElement(rank, file);
            if (!square) return;
            
            const piece = document.createElement('div');
            piece.className = `piece ${color}`;
            piece.dataset.type = type;
            piece.dataset.color = color;
            piece.draggable = true;
            
            // Устанавливаем символ Unicode для фигуры
            const pieceSymbols = {
                'white': { 'king': '♔', 'queen': '♕', 'rook': '♖', 'bishop': '♗', 'knight': '♘', 'pawn': '♙' },
                'black': { 'king': '♚', 'queen': '♛', 'rook': '♜', 'bishop': '♝', 'knight': '♞', 'pawn': '♟' }
            };
            
            piece.textContent = pieceSymbols[color][type];
            
            // Добавляем обработчики для drag and drop
            piece.addEventListener('dragstart', handleDragStart);
            piece.addEventListener('dragend', handleDragEnd);
            
            square.appendChild(piece);
            boardState[rank][file] = { type, color, hasMoved: false };
        }
        
        // Получение элемента клетки по координатам
        function getSquareElement(rank, file) {
            const squares = document.querySelectorAll('.square');
            for (const square of squares) {
                if (parseInt(square.dataset.rank) === rank && parseInt(square.dataset.file) === file) {
                    return square;
                }
            }
            return null;
        }
        
        // Обработчик клика по клетке
        function handleSquareClick(event) {
            const square = event.currentTarget;
            const rank = parseInt(square.dataset.rank);
            const file = parseInt(square.dataset.file);
            
            // Если клетка уже выбрана, снимаем выделение
            if (selectedSquare === square) {
                clearSelection();
                return;
            }
            
            // Если есть выбранная клетка, пытаемся сделать ход
            if (selectedSquare) {
                const fromRank = parseInt(selectedSquare.dataset.rank);
                const fromFile = parseInt(selectedSquare.dataset.file);
                
                // Проверяем, является ли ход допустимым
                if (isValidMove(fromRank, fromFile, rank, file)) {
                    makeMove(fromRank, fromFile, rank, file);
                    clearSelection();
                    return;
                }
            }
            
            // Выбираем клетку, если на ней есть фигура текущего игрока
            const piece = boardState[rank][file];
            if (piece && piece.color === currentPlayer) {
                clearSelection();
                selectedSquare = square;
                square.classList.add('selected');
                
                // Показываем допустимые ходы
                showValidMoves(rank, file);
            } else {
                clearSelection();
            }
        }
        
        // Показать допустимые ходы для фигуры
        function showValidMoves(rank, file) {
            validMoves = calculateValidMoves(rank, file);
            
            validMoves.forEach(move => {
                const square = getSquareElement(move.rank, move.file);
                if (square) {
                    if (boardState[move.rank][move.file]) {
                        square.classList.add('valid-capture');
                    } else {
                        square.classList.add('valid-move');
                    }
                }
            });
        }
        
        // Очистка выделения и допустимых ходов
        function clearSelection() {
            if (selectedSquare) {
                selectedSquare.classList.remove('selected');
                selectedSquare = null;
            }
            
            document.querySelectorAll('.valid-move, .valid-capture').forEach(el => {
                el.classList.remove('valid-move');
                el.classList.remove('valid-capture');
            });
            
            validMoves = [];
        }
        
        // Обработчики для drag and drop
        function handleDragStart(event) {
            const piece = event.target;
            const square = piece.parentElement;
            const rank = parseInt(square.dataset.rank);
            const file = parseInt(square.dataset.file);
            
            // Проверяем, принадлежит ли фигура текущему игроку
            if (boardState[rank][file].color !== currentPlayer) {
                event.preventDefault();
                return;
            }
            
            piece.classList.add('dragging');
            event.dataTransfer.setData('text/plain', `${rank},${file}`);
            
            // Показываем допустимые ходы
            showValidMoves(rank, file);
        }
        
        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            clearSelection();
        }
        
        function handleDragOver(event) {
            event.preventDefault();
        }
        
        function handleDrop(event) {
            event.preventDefault();
            const square = event.currentTarget;
            
            const data = event.dataTransfer.getData('text/plain');
            if (!data) return;
            
            const [fromRank, fromFile] = data.split(',').map(Number);
            const toRank = parseInt(square.dataset.rank);
            const toFile = parseInt(square.dataset.file);
            
            if (isValidMove(fromRank, fromFile, toRank, toFile)) {
                makeMove(fromRank, fromFile, toRank, toFile);
            }
            
            clearSelection();
        }
        
        // Проверка допустимости хода
        function isValidMove(fromRank, fromFile, toRank, toFile) {
            // Проверяем, не пытаемся ли переместиться на ту же клетку
            if (fromRank === toRank && fromFile === toFile) return false;
            
            // Проверяем, есть ли фигура в начальной позиции
            const piece = boardState[fromRank][fromFile];
            if (!piece) return false;
            
            // Проверяем, принадлежит ли фигура текущему игроку
            if (piece.color !== currentPlayer) return false;
            
            // Проверяем, не пытаемся ли съесть свою фигуру
            const targetPiece = boardState[toRank][toFile];
            if (targetPiece && targetPiece.color === currentPlayer) return false;
            
            // Проверяем правила для каждой фигуры
            return isValidMoveForPiece(piece, fromRank, fromFile, toRank, toFile);
        }
        
        // Проверка допустимости хода для конкретной фигуры
        function isValidMoveForPiece(piece, fromRank, fromFile, toRank, toFile) {
            const rankDiff = toRank - fromRank;
            const fileDiff = toFile - fromFile;
            const absRankDiff = Math.abs(rankDiff);
            const absFileDiff = Math.abs(fileDiff);
            
            switch (piece.type) {
                case 'pawn':
                    return isValidPawnMove(piece, fromRank, fromFile, toRank, toFile);
                case 'knight':
                    return (absRankDiff === 2 && absFileDiff === 1) || (absRankDiff === 1 && absFileDiff === 2);
                case 'bishop':
                    return absRankDiff === absFileDiff && isPathClear(fromRank, fromFile, toRank, toFile);
                case 'rook':
                    return (fromRank === toRank || fromFile === toFile) && isPathClear(fromRank, fromFile, toRank, toFile);
                case 'queen':
                    return (fromRank === toRank || fromFile === toFile || absRankDiff === absFileDiff) && 
                           isPathClear(fromRank, fromFile, toRank, toFile);
                case 'king':
                    return absRankDiff <= 1 && absFileDiff <= 1;
                default:
                    return false;
            }
        }
        
        // Проверка хода пешки
        function isValidPawnMove(piece, fromRank, fromFile, toRank, toFile) {
            const direction = piece.color === 'white' ? -1 : 1;
            const startRank = piece.color === 'white' ? 6 : 1;
            const targetPiece = boardState[toRank][toFile];
            
            // Движение вперед
            if (fromFile === toFile && !targetPiece) {
                // Обычный ход на одну клетку
                if (toRank === fromRank + direction) return true;
                // Первый ход на две клетки
                if (fromRank === startRank && toRank === fromRank + 2 * direction && 
                    !boardState[fromRank + direction][fromFile]) return true;
            }
            
            // Взятие по диагонали
            if (abs(fileDiff) === 1 && toRank === fromRank + direction && targetPiece) {
                return true;
            }
            
            // Взятие на проходе (упрощенно)
            // Рокировка (упрощенно)
            
            return false;
        }
        
        // Проверка, свободен ли путь
        function isPathClear(fromRank, fromFile, toRank, toFile) {
            const rankStep = toRank === fromRank ? 0 : (toRank > fromRank ? 1 : -1);
            const fileStep = toFile === fromFile ? 0 : (toFile > fromFile ? 1 : -1);
            
            let currentRank = fromRank + rankStep;
            let currentFile = fromFile + fileStep;
            
            while (currentRank !== toRank || currentFile !== toFile) {
                if (boardState[currentRank][currentFile]) return false;
                currentRank += rankStep;
                currentFile += fileStep;
            }
            
            return true;
        }
        
        // Выполнение хода
        function makeMove(fromRank, fromFile, toRank, toFile) {
            const piece = boardState[fromRank][fromFile];
            const targetPiece = boardState[toRank][toFile];
            
            // Сохраняем информацию о ходе для истории
            const move = {
                from: { rank: fromRank, file: fromFile },
                to: { rank: toRank, file: toFile },
                piece: { ...piece },
                captured: targetPiece,
                notation: getMoveNotation(fromRank, fromFile, toRank, toFile, targetPiece),
                index: moveHistory.length
            };
            
            // Выполняем перемещение
            const fromSquare = getSquareElement(fromRank, fromFile);
            const toSquare = getSquareElement(toRank, toFile);
            
            // Очищаем целевую клетку
            if (toSquare.querySelector('.piece')) {
                toSquare.removeChild(toSquare.querySelector('.piece'));
            }
            
            // Перемещаем фигуру
            const pieceElement = fromSquare.querySelector('.piece');
            toSquare.appendChild(pieceElement);
            
            // Обновляем состояние доски
            boardState[toRank][toFile] = { ...piece, hasMoved: true };
            boardState[fromRank][fromFile] = null;
            
            // Обработка превращения пешки (упрощенно)
            if (piece.type === 'pawn' && (toRank === 0 || toRank === 7)) {
                // Автоматическое превращение в ферзя
                boardState[toRank][toFile].type = 'queen';
                pieceElement.textContent = piece.color === 'white' ? '♕' : '♛';
                pieceElement.dataset.type = 'queen';
            }
            
            // Обновляем историю ходов
            if (currentMoveIndex < moveHistory.length - 1) {
                // Если мы не в конце истории, обрезаем ее
                moveHistory = moveHistory.slice(0, currentMoveIndex + 1);
                positionHistory = positionHistory.slice(0, currentMoveIndex + 1);
            }
            
            moveHistory.push(move);
            currentMoveIndex = moveHistory.length - 1;
            
            // Обновляем счетчик ходов для правила 50 ходов
            if (piece.type === 'pawn' || targetPiece) {
                halfMoveClock = 0;
            } else {
                halfMoveClock++;
            }
            
            // Обновляем номер полного хода
            if (currentPlayer === 'black') {
                fullMoveNumber++;
            }
            
            // Сохраняем позицию для проверки трехкратного повторения
            savePositionToHistory();
            
            // Меняем игрока
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // Проверяем состояние игры
            checkGameStatus();
            
            // Обновляем интерфейс
            updateMovesList();
            updateStatusBar();
            updateEvaluation();
        }
        
        // Получение нотации хода
        function getMoveNotation(fromRank, fromFile, toRank, toFile, captured) {
            const piece = boardState[fromRank][fromFile];
            const fileChar = FILES[fromFile];
            const toFileChar = FILES[toFile];
            const toRankChar = RANKS[toRank];
            
            let notation = '';
            
            // Для пешки обозначение отличается
            if (piece.type !== 'pawn') {
                notation += piece.type === 'knight' ? 'N' : piece.type.charAt(0).toUpperCase();
            }
            
            // Обозначение взятия
            if (captured) {
                if (piece.type === 'pawn') {
                    notation += fileChar;
                }
                notation += 'x';
            }
            
            // Конечная позиция
            notation += toFileChar + toRankChar;
            
            return notation;
        }
        
        // Сохранение позиции в историю для проверки трехкратного повторения
        function savePositionToHistory() {
            // Создаем строковое представление позиции
            let positionString = '';
            for (let rank = 0; rank < 8; rank++) {
                for (let file = 0; file < 8; file++) {
                    const piece = boardState[rank][file];
                    if (piece) {
                        positionString += piece.color.charAt(0) + piece.type.charAt(0);
                    } else {
                        positionString += '--';
                    }
                }
            }
            positionString += currentPlayer;
            
            positionHistory.push(positionString);
        }
        
        // Проверка состояния игры
        function checkGameStatus() {
            // Проверка на шах
            const inCheck = isKingInCheck(currentPlayer);
            
            // Проверка на мат
            const hasLegalMoves = hasAnyLegalMoves(currentPlayer);
            
            if (inCheck && !hasLegalMoves) {
                gameStatus = 'checkmate';
            } else if (!inCheck && !hasLegalMoves) {
                gameStatus = 'stalemate';
            } else if (inCheck) {
                gameStatus = 'check';
            } else {
                gameStatus = 'active';
            }
            
            // Проверка на пат по правилу 50 ходов
            if (halfMoveClock >= 100) { // 50 полных ходов = 100 полуходов
                gameStatus = 'draw';
            }
            
            // Проверка на трехкратное повторение позиции
            const currentPosition = positionHistory[positionHistory.length - 1];
            let repetitionCount = 0;
            
            for (let i = 0; i < positionHistory.length - 1; i++) {
                if (positionHistory[i] === currentPosition) {
                    repetitionCount++;
                }
            }
            
            if (repetitionCount >= 2) { // Текущая позиция + 2 повторения = 3 раза
                gameStatus = 'draw';
            }
        }
        
        // Проверка, находится ли король под шахом
        function isKingInCheck(color) {
            // Находим позицию короля
            let kingRank, kingFile;
            for (let rank = 0; rank < 8; rank++) {
                for (let file = 0; file < 8; file++) {
                    const piece = boardState[rank][file];
                    if (piece && piece.type === 'king' && piece.color === color) {
                        kingRank = rank;
                        kingFile = file;
                        break;
                    }
                }
            }
            
            // Проверяем, может ли любая фигура противника атаковать короля
            const opponentColor = color === 'white' ? 'black' : 'white';
            for (let rank = 0; rank < 8; rank++) {
                for (let file = 0; file < 8; file++) {
                    const piece = boardState[rank][file];
                    if (piece && piece.color === opponentColor) {
                        if (isValidMoveForPiece(piece, rank, file, kingRank, kingFile)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // Проверка, есть ли у игрока допустимые ходы
        function hasAnyLegalMoves(color) {
            // Для демонстрации всегда возвращаем true
            // В реальной реализации нужно проверить все возможные ходы
            return true;
        }
        
        // Расчет допустимых ходов для фигуры
        function calculateValidMoves(rank, file) {
            const moves = [];
            const piece = boardState[rank][file];
            
            if (!piece) return moves;
            
            // Для демонстрации генерируем несколько случайных допустимых ходов
            // В реальной реализации нужно учитывать правила для каждой фигуры
            
            for (let r = 0; r < 8; r++) {
                for (let f = 0; f < 8; f++) {
                    if (isValidMove(rank, file, r, f)) {
                        moves.push({ rank: r, file: f });
                    }
                }
            }
            
            return moves;
        }
        
        // Обновление списка ходов
        function updateMovesList() {
            const movesList = document.getElementById('movesList');
            const moveCount = document.getElementById('moveCount');
            
            movesList.innerHTML = '';
            moveCount.textContent = moveHistory.length;
            
            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveRow = document.createElement('div');
                moveRow.className = `move-row ${i === currentMoveIndex || i+1 === currentMoveIndex ? 'active' : ''}`;
                moveRow.addEventListener('click', () => navigateToMove(i));
                
                const moveNumber = document.createElement('div');
                moveNumber.className = 'move-number';
                moveNumber.textContent = `${Math.floor(i/2) + 1}.`;
                
                const moveWhite = document.createElement('div');
                moveWhite.className = 'move-white';
                moveWhite.textContent = moveHistory[i].notation;
                
                const moveBlack = document.createElement('div');
                moveBlack.className = 'move-black';
                
                if (i + 1 < moveHistory.length) {
                    moveBlack.textContent = moveHistory[i + 1].notation;
                }
                
                moveRow.appendChild(moveNumber);
                moveRow.appendChild(moveWhite);
                moveRow.appendChild(moveBlack);
                
                movesList.appendChild(moveRow);
            }
            
            // Прокручиваем к активному ходу
            const activeMove = movesList.querySelector('.active');
            if (activeMove) {
                activeMove.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        // Навигация по ходам
        function navigateToMove(moveIndex) {
            // Сбрасываем доску к начальной позиции
            setupPieces();
            currentMoveIndex = -1;
            
            // Воспроизводим ходы до выбранного индекса
            for (let i = 0; i <= moveIndex; i++) {
                const move = moveHistory[i];
                makeMoveWithoutHistory(move.from.rank, move.from.file, move.to.rank, move.to.file);
            }
            
            currentMoveIndex = moveIndex;
            updateMovesList();
            updateStatusBar();
        }
        
        // Выполнение хода без добавления в историю (для навигации)
        function makeMoveWithoutHistory(fromRank, fromFile, toRank, toFile) {
            const piece = boardState[fromRank][fromFile];
            const targetPiece = boardState[toRank][toFile];
            
            // Выполняем перемещение
            const fromSquare = getSquareElement(fromRank, fromFile);
            const toSquare = getSquareElement(toRank, toFile);
            
            // Очищаем целевую клетку
            if (toSquare.querySelector('.piece')) {
                toSquare.removeChild(toSquare.querySelector('.piece'));
            }
            
            // Перемещаем фигуру
            const pieceElement = fromSquare.querySelector('.piece');
            toSquare.appendChild(pieceElement);
            
            // Обновляем состояние доски
            boardState[toRank][toFile] = { ...piece, hasMoved: true };
            boardState[fromRank][fromFile] = null;
            
            // Обработка превращения пешки
            if (piece.type === 'pawn' && (toRank === 0 || toRank === 7)) {
                boardState[toRank][toFile].type = 'queen';
                pieceElement.textContent = piece.color === 'white' ? '♕' : '♛';
                pieceElement.dataset.type = 'queen';
            }
            
            // Меняем игрока
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
        }
        
        // Обновление строки состояния
        function updateStatusBar() {
            const statusBar = document.getElementById('statusBar');
            let statusText = '';
            
            switch (gameStatus) {
                case 'active':
                    statusText = `Ход ${currentPlayer === 'white' ? 'белых' : 'черных'}`;
                    break;
                case 'check':
                    statusText = `ШАХ! Ход ${currentPlayer === 'white' ? 'белых' : 'черных'}`;
                    statusBar.className = 'status-bar status-check';
                    break;
                case 'checkmate':
                    statusText = `МАТ! Победа ${currentPlayer === 'white' ? 'черных' :
