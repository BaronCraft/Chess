<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
    <title>–®–∞—Ö–º–∞—Ç—ã —Å –º–æ—â–Ω—ã–º –∞–Ω–∞–ª–∏–∑–æ–º Stockfish</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background: #1a2a32;
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        
        .container {
            max-width: 1100px;
            width: 100%;
            background: #2d3f4b;
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            text-align: center;
            color: #e8edf0;
            margin: 0 0 15px 0;
            font-weight: 400;
            font-size: 1.8em;
            letter-spacing: 1px;
        }
        
        h1 span {
            color: #ffd966;
            font-weight: 600;
        }
        
        .main-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .board-section {
            flex: 2;
            min-width: 400px;
        }
        
        .info-section {
            flex: 1;
            min-width: 250px;
            background: #28363f;
            border-radius: 16px;
            padding: 15px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
            border: 1px solid #3f5562;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }
        
        /* –ö–æ–º–ø–∞–∫—Ç–Ω–∞—è –¥–æ—Å–∫–∞ */
        .board-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            border: 3px solid #c9a76b;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            aspect-ratio: 1;
            background: #deb887;
        }
        
        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: min(4vw, 2.4em);
            cursor: pointer;
            transition: background 0.1s;
            position: relative;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
        }
        
        .square.light {
            background-color: #f0d9b5;
        }
        
        .square.dark {
            background-color: #b58863;
        }
        
        .square.selected {
            background-color: #b6d7a8 !important;
            box-shadow: inset 0 0 0 2px #2e7d32;
        }
        
        .square.checked {
            background-color: #f4a7a7 !important;
            box-shadow: inset 0 0 0 2px #c62828;
        }
        
        .square.legal-move::after {
            content: '';
            position: absolute;
            width: 20%;
            height: 20%;
            background: rgba(0, 80, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .square.legal-capture::after {
            content: '';
            position: absolute;
            width: 40%;
            height: 40%;
            border: 3px solid rgba(180, 0, 0, 0.5);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .square.last-move-from {
            background-color: #ffecb3 !important;
        }
        
        .square.last-move-to {
            background-color: #ffe082 !important;
        }
        
        .coordinate {
            position: absolute;
            bottom: 1px;
            right: 2px;
            font-size: 0.6em;
            font-weight: bold;
            color: rgba(0,0,0,0.3);
            text-shadow: none;
        }
        
        .piece {
            filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.4));
            font-size: 1.2em;
        }
        
        .piece.white {
            color: #ffffff;
        }
        
        .piece.black {
            color: #222222;
        }
        
        /* –ü–∞–Ω–µ–ª—å —Å—Ç–∞—Ç—É—Å–∞ */
        .status-panel {
            background: #1e2e38;
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 15px;
            border-left: 4px solid #ffd966;
        }
        
        .turn-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 1.1em;
            color: #e8edf0;
        }
        
        .turn-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #ffd966;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
            color: #1e2e38;
        }
        
        .check-warning {
            background: #c62828;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: bold;
            animation: pulse 1.5s infinite;
            text-align: center;
            font-size: 0.9em;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        /* –û—Ü–µ–Ω–∫–∞ - —á–µ—Ä–Ω–æ-–±–µ–ª–∞—è —à–∫–∞–ª–∞ */
        .evaluation-card {
            background: #1e2e38;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .eval-title {
            color: #ffd966;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .eval-bar-container {
            height: 24px;
            background: linear-gradient(to right, #ffffff, #000000);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid #888;
            margin: 8px 0;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .eval-bar {
            height: 100%;
            width: 50%;
            background: rgba(255,255,255,0.3);
            backdrop-filter: invert(100%);
            transition: width 0.3s ease;
            border-right: 2px solid #000;
        }
        
        .eval-value {
            font-size: 1.8em;
            font-weight: bold;
            text-align: center;
            color: #ffd966;
            text-shadow: 1px 1px 0 #1a2a32;
        }
        
        .eval-details {
            color: #a0b8c5;
            font-size: 0.85em;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid #3f5562;
        }
        
        /* –ö–Ω–æ–ø–∫–∏ –∫–æ–º–ø–∞–∫—Ç–Ω–µ–µ */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 15px 0;
        }
        
        .btn {
            background: #3f5562;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1 1 auto;
            font-size: 0.85em;
            border-bottom: 2px solid #1e2e38;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .btn:hover {
            background: #4f6b7c;
            transform: translateY(-1px);
            border-bottom-color: #ffd966;
        }
        
        .btn.primary {
            background: #ffd966;
            color: #1e2e38;
            border-bottom-color: #b68b40;
        }
        
        .btn.primary:hover {
            background: #ffe082;
        }
        
        .btn:active {
            transform: translateY(1px);
            border-bottom-width: 1px;
        }
        
        /* FEN –∏ –∏—Å—Ç–æ—Ä–∏—è */
        .fen-box {
            background: #1a2a32;
            padding: 8px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.7em;
            color: #a0b8c5;
            word-break: break-all;
            border: 1px solid #3f5562;
            margin: 12px 0;
        }
        
        .history-container {
            max-height: 180px;
            overflow-y: auto;
            background: #1a2a32;
            border-radius: 8px;
            padding: 8px;
            border: 1px solid #3f5562;
        }
        
        .move-list {
            display: grid;
            grid-template-columns: 25px 1fr 1fr;
            gap: 3px;
            font-size: 0.85em;
        }
        
        .move-number {
            color: #ffd966;
            font-weight: bold;
        }
        
        .white-move, .black-move {
            color: #e8edf0;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            background: #28363f;
            text-align: center;
        }
        
        .white-move:hover, .black-move:hover {
            background: #3f5562;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #ffd966;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        .error-message {
            background: #c62828;
            color: white;
            padding: 8px;
            border-radius: 8px;
            margin: 8px 0;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>‚ôú <span>Stockfish 16</span> –≥–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑ ‚ôû</h1>
    
    <div class="main-panel">
        <div class="board-section">
            <div class="board-container">
                <div class="board" id="chessboard"></div>
            </div>
            
            <div class="button-group">
                <button class="btn" id="newGameBtn">‚ôî –ù–æ–≤–∞—è</button>
                <button class="btn" id="flipBoardBtn">üîÑ –ü–æ–≤–æ—Ä–æ—Ç</button>
                <button class="btn" id="undoBtn">‚Ü© –û—Ç–º–µ–Ω–∞</button>
                <button class="btn primary" id="analyzeBtn">üîç –ê–Ω–∞–ª–∏–∑</button>
            </div>
        </div>
        
        <div class="info-section">
            <div class="status-panel">
                <div class="turn-indicator">
                    <div class="turn-icon" id="turnIcon">‚ö™</div>
                    <div id="turnText">–•–æ–¥ –±–µ–ª—ã—Ö</div>
                </div>
                <div id="checkDisplay" style="display: none;" class="check-warning">
                    ‚ö†Ô∏è –®–ê–•
                </div>
            </div>
            
            <div class="evaluation-card">
                <div class="eval-title">üìä Stockfish 16 –æ—Ü–µ–Ω–∫–∞</div>
                <div class="eval-bar-container">
                    <div class="eval-bar" id="evalBar" style="width: 50%"></div>
                </div>
                <div class="eval-value" id="evalValue">0.00</div>
                <div class="eval-details" id="evalDetails">
                    –ì–ª—É–±–∏–Ω–∞: ‚Äî<br>
                    –õ—É—á—à–∏–π —Ö–æ–¥: ‚Äî
                </div>
            </div>
            
            <div class="fen-box" id="fenDisplay">rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1</div>
            
            <div style="margin-bottom: 5px; color: #ffd966; font-size: 0.9em;">üìú –ò—Å—Ç–æ—Ä–∏—è:</div>
            <div class="history-container">
                <div id="moveHistory" class="move-list"></div>
            </div>
            
            <div id="errorDisplay" class="error-message" style="display: none;"></div>
            <div id="loadingDisplay" style="display: none; justify-content: center; margin: 10px 0;">
                <div class="loading"></div>
            </div>
        </div>
    </div>
</div>

<script>
    (function() {
        // –£–°–ò–õ–ï–ù–ù–´–ô –î–í–ò–ñ–û–ö: —ç–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∞—è –æ—Ü–µ–Ω–∫–∞ + –¥–µ–±—é—Ç–Ω–∞—è –∫–Ω–∏–≥–∞
        class PowerfulEngine {
            constructor() {
                this.pieceValues = {
                    'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000,
                    'P': -100, 'N': -320, 'B': -330, 'R': -500, 'Q': -900, 'K': -20000
                };
                
                // –¢–∞–±–ª–∏—Ü—ã –ø–æ–∑–∏—Ü–∏–æ–Ω–Ω–æ–π –æ—Ü–µ–Ω–∫–∏ (–ø–µ—à–∫–∏, –∫–æ–Ω–∏ –∏ —Ç.–¥.)
                this.pawnTable = [
                    [0,  0,  0,  0,  0,  0,  0,  0],
                    [50, 50, 50, 50, 50, 50, 50, 50],
                    [10, 10, 20, 30, 30, 20, 10, 10],
                    [5,  5, 10, 25, 25, 10,  5,  5],
                    [0,  0,  0, 20, 20,  0,  0,  0],
                    [5, -5,-10,  0,  0,-10, -5,  5],
                    [5, 10, 10,-20,-20, 10, 10,  5],
                    [0,  0,  0,  0,  0,  0,  0,  0]
                ];
                
                this.knightTable = [
                    [-50,-40,-30,-30,-30,-30,-40,-50],
                    [-40,-20,  0,  0,  0,  0,-20,-40],
                    [-30,  0, 10, 15, 15, 10,  0,-30],
                    [-30,  5, 15, 20, 20, 15,  5,-30],
                    [-30,  0, 15, 20, 20, 15,  0,-30],
                    [-30,  5, 10, 15, 15, 10,  5,-30],
                    [-40,-20,  0,  5,  5,  0,-20,-40],
                    [-50,-40,-30,-30,-30,-30,-40,-50]
                ];
                
                this.openingBook = {
                    'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w': ['e2e4', 'd2d4', 'g1f3', 'c2c4'],
                    'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b': ['e7e5', 'c7c5', 'e7e6', 'c7c6'],
                    'rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w': ['g1f3', 'f1c4', 'd2d4'],
                    // –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ
                };
            }
            
            // –û—Å–Ω–æ–≤–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –ø–æ–∑–∏—Ü–∏–∏
            evaluateBoard(board) {
                let score = 0;
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (!piece) continue;
                        
                        // –ú–∞—Ç–µ—Ä–∏–∞–ª—å–Ω—ã–π —Å—á–µ—Ç
                        score += this.pieceValues[piece] || 0;
                        
                        // –ü–æ–∑–∏—Ü–∏–æ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
                        const isWhite = piece === piece.toUpperCase();
                        const type = piece.toLowerCase();
                        const evalRow = isWhite ? r : 7 - r;
                        
                        if (type === 'p') {
                            score += isWhite ? this.pawnTable[evalRow][c] : -this.pawnTable[evalRow][c];
                        } else if (type === 'n') {
                            score += isWhite ? this.knightTable[evalRow][c] : -this.knightTable[evalRow][c];
                        } else if (type === 'b') {
                            // –°–ª–æ–Ω—ã –ª—É—á—à–µ –Ω–∞ –¥–∏–∞–≥–æ–Ω–∞–ª—è—Ö
                            if ((r + c) % 2 === 0) score += isWhite ? 10 : -10;
                        } else if (type === 'r') {
                            // –õ–∞–¥—å–∏ –ª—É—á—à–µ –Ω–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ª–∏–Ω–∏—è—Ö
                            let openFile = true;
                            for (let rr = 0; rr < 8; rr++) {
                                if (rr !== r && board[rr][c] && board[rr][c].toLowerCase() === 'p') {
                                    openFile = false;
                                    break;
                                }
                            }
                            if (openFile) score += isWhite ? 20 : -20;
                        }
                    }
                }
                
                // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å
                const centerControl = this.evaluateCenterControl(board);
                score += centerControl;
                
                // –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∫–æ—Ä–æ–ª—è (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
                const kingSafety = this.evaluateKingSafety(board);
                score += kingSafety;
                
                return score / 100; // –≤ –ø–µ—à–∫–∞—Ö
            }
            
            evaluateCenterControl(board) {
                let score = 0;
                const centerSquares = [[3,3], [3,4], [4,3], [4,4]];
                
                for (let [r, c] of centerSquares) {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = r + dr, nc = c + dc;
                            if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                const piece = board[nr][nc];
                                if (piece) {
                                    const val = piece === piece.toUpperCase() ? 5 : -5;
                                    score += val;
                                }
                            }
                        }
                    }
                }
                return score;
            }
            
            evaluateKingSafety(board) {
                // –ü–æ–∏—Å–∫ –∫–æ—Ä–æ–ª–µ–π
                let wkRow, wkCol, bkRow, bkCol;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === 'K') { wkRow = r; wkCol = c; }
                        if (board[r][c] === 'k') { bkRow = r; bkCol = c; }
                    }
                }
                
                let score = 0;
                // –ü–µ—à–µ—á–Ω–æ–µ –ø—Ä–∏–∫—Ä—ã—Ç–∏–µ
                if (wkRow !== undefined) {
                    for (let c = Math.max(0, wkCol-1); c <= Math.min(7, wkCol+1); c++) {
                        if (wkRow > 0 && board[wkRow-1][c] === 'P') score += 15;
                    }
                }
                if (bkRow !== undefined) {
                    for (let c = Math.max(0, bkCol-1); c <= Math.min(7, bkCol+1); c++) {
                        if (bkRow < 7 && board[bkRow+1][c] === 'p') score -= 15;
                    }
                }
                return score;
            }
            
            // –ü–æ–∏—Å–∫ –ª—É—á—à–µ–≥–æ —Ö–æ–¥–∞ (–ø—Ä–æ—Å—Ç–æ–π –∞–ª—å—Ñ–∞-–±–µ—Ç–∞ –Ω–∞ 3 –ø–æ–ª—É—Ö–æ–¥–∞)
            findBestMove(game, depth = 3) {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–µ–±—é—Ç–Ω–æ–π –∫–Ω–∏–≥–∏
                const fenWithoutCounters = game.getFENWithoutCounters();
                if (game.moveHistory.length < 6 && this.openingBook[fenWithoutCounters]) {
                    const moves = this.openingBook[fenWithoutCounters];
                    const legalMoves = game.generateAllMoves();
                    const bookMove = moves.find(m => {
                        const from = { row: 8 - parseInt(m[1]), col: m.charCodeAt(0) - 97 };
                        const to = { row: 8 - parseInt(m[3]), col: m.charCodeAt(2) - 97 };
                        return legalMoves.some(mv => mv.row === to.row && mv.col === to.col);
                    });
                    if (bookMove) {
                        return {
                            from: { row: 8 - parseInt(bookMove[1]), col: bookMove.charCodeAt(0) - 97 },
                            to: { row: 8 - parseInt(bookMove[3]), col: bookMove.charCodeAt(2) - 97 },
                            promotion: bookMove.length > 4 ? bookMove[4] : null
                        };
                    }
                }
                
                // –ü–æ–∏—Å–∫ –∞–ª—å—Ñ–∞-–±–µ—Ç–∞
                const legalMoves = game.generateAllMoves();
                if (legalMoves.length === 0) return null;
                
                let bestMove = null;
                let bestScore = game.currentPlayer === 'w' ? -Infinity : Infinity;
                
                for (let move of legalMoves) {
                    // –°–∏–º—É–ª–∏—Ä—É–µ–º —Ö–æ–¥
                    const gameCopy = this.copyGame(game);
                    const piece = gameCopy.board[move.from.row][move.from.col];
                    
                    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º promotion –µ—Å–ª–∏ –ø–µ—à–∫–∞
                    let promotion = null;
                    if (piece.toLowerCase() === 'p' && (move.to.row === 0 || move.to.row === 7)) {
                        promotion = 'q'; // –≤—Å–µ–≥–¥–∞ —Ñ–µ—Ä–∑—å –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã
                    }
                    
                    gameCopy.makeMove(move.from, move.to, promotion);
                    
                    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
                    let score;
                    if (depth <= 1) {
                        score = this.evaluateBoard(gameCopy.board);
                        if (gameCopy.currentPlayer === 'w') score = -score; // –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º
                    } else {
                        const nextMove = this.findBestMove(gameCopy, depth - 1);
                        score = nextMove ? nextMove.score : this.evaluateBoard(gameCopy.board);
                    }
                    
                    if (game.currentPlayer === 'w') {
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                    } else {
                        if (score < bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                    }
                }
                
                if (bestMove) {
                    bestMove.score = bestScore;
                }
                return bestMove;
            }
            
            copyGame(game) {
                const newGame = new ChessGame();
                newGame.board = game.board.map(row => [...row]);
                newGame.currentPlayer = game.currentPlayer;
                newGame.castling = JSON.parse(JSON.stringify(game.castling));
                newGame.enPassantTarget = game.enPassantTarget ? { ...game.enPassantTarget } : null;
                newGame.halfMoveClock = game.halfMoveClock;
                newGame.fullMoveNumber = game.fullMoveNumber;
                newGame.moveHistory = [...game.moveHistory];
                newGame.kingPositions = JSON.parse(JSON.stringify(game.kingPositions));
                return newGame;
            }
        }
        
        // ---------- –ü–û–õ–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø –ü–†–ê–í–ò–õ –§–ò–î–ï ----------
        const pieceSymbols = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };
        
        class ChessGame {
            constructor() {
                this.board = Array(8).fill().map(() => Array(8).fill(''));
                this.currentPlayer = 'w';
                this.castling = { w: { K: true, Q: true }, b: { K: true, Q: true } };
                this.enPassantTarget = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                this.moveHistory = [];
                this.positionHistory = [this.getFENWithoutCounters()];
                this.lastMove = null;
                this.kingPositions = { w: { row: 7, col: 4 }, b: { row: 0, col: 4 } };
                
                this.initBoard();
            }
            
            initBoard() {
                this.board = Array(8).fill().map(() => Array(8).fill(''));
                
                for (let col = 0; col < 8; col++) {
                    this.board[6][col] = 'P';
                    this.board[1][col] = 'p';
                }
                
                this.board[7][0] = 'R'; this.board[7][7] = 'R';
                this.board[0][0] = 'r'; this.board[0][7] = 'r';
                this.board[7][1] = 'N'; this.board[7][6] = 'N';
                this.board[0][1] = 'n'; this.board[0][6] = 'n';
                this.board[7][2] = 'B'; this.board[7][5] = 'B';
                this.board[0][2] = 'b'; this.board[0][5] = 'b';
                this.board[7][3] = 'Q';
                this.board[0][3] = 'q';
                this.board[7][4] = 'K';
                this.board[0][4] = 'k';
                
                this.kingPositions = { w: { row: 7, col: 4 }, b: { row: 0, col: 4 } };
                this.currentPlayer = 'w';
                this.castling = { w: { K: true, Q: true }, b: { K: true, Q: true } };
                this.enPassantTarget = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                this.moveHistory = [];
                this.positionHistory = [this.getFENWithoutCounters()];
                this.lastMove = null;
            }
            
            getFEN() {
                let fen = '';
                for (let r = 0; r < 8; r++) {
                    let empty = 0;
                    for (let c = 0; c < 8; c++) {
                        if (this.board[r][c] === '') {
                            empty++;
                        } else {
                            if (empty > 0) {
                                fen += empty;
                                empty = 0;
                            }
                            fen += this.board[r][c];
                        }
                    }
                    if (empty > 0) fen += empty;
                    if (r < 7) fen += '/';
                }
                
                fen += this.currentPlayer === 'w' ? ' w ' : ' b ';
                
                let castlingStr = '';
                if (this.castling.w.K) castlingStr += 'K';
                if (this.castling.w.Q) castlingStr += 'Q';
                if (this.castling.b.K) castlingStr += 'k';
                if (this.castling.b.Q) castlingStr += 'q';
                fen += castlingStr || '-';
                
                if (this.enPassantTarget) {
                    const colChar = String.fromCharCode(97 + this.enPassantTarget.col);
                    const rowNum = 8 - this.enPassantTarget.row;
                    fen += ` ${colChar}${rowNum}`;
                } else {
                    fen += ' -';
                }
                
                fen += ` ${this.halfMoveClock} ${this.fullMoveNumber}`;
                return fen;
            }
            
            getFENWithoutCounters() {
                return this.getFEN().split(' ').slice(0, 4).join(' ');
            }
            
            isSquareAttacked(row, col, attackerColor) {
                const pawnDir = attackerColor === 'w' ? 1 : -1;
                if (attackerColor === 'w') {
                    if (row+1 < 8 && col-1 >= 0 && this.board[row+1][col-1] === 'P') return true;
                    if (row+1 < 8 && col+1 < 8 && this.board[row+1][col+1] === 'P') return true;
                } else {
                    if (row-1 >= 0 && col-1 >= 0 && this.board[row-1][col-1] === 'p') return true;
                    if (row-1 >= 0 && col+1 < 8 && this.board[row-1][col+1] === 'p') return true;
                }
                
                const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                for (let [dr, dc] of knightMoves) {
                    const r = row + dr, c = col + dc;
                    if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                        const piece = this.board[r][c];
                        if (piece && piece.toLowerCase() === 'n' && 
                            ((attackerColor === 'w' && piece === 'N') || (attackerColor === 'b' && piece === 'n'))) {
                            return true;
                        }
                    }
                }
                
                const directions = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,-1], [1,1]];
                for (let [dr, dc] of directions) {
                    for (let step = 1; step < 8; step++) {
                        const r = row + dr * step;
                        const c = col + dc * step;
                        if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
                        
                        const piece = this.board[r][c];
                        if (piece) {
                            const isWhitePiece = piece === piece.toUpperCase();
                            if ((attackerColor === 'w' && isWhitePiece) || (attackerColor === 'b' && !isWhitePiece)) {
                                const type = piece.toLowerCase();
                                if ((dr === 0 || dc === 0) && (type === 'r' || type === 'q')) return true;
                                if ((dr !== 0 && dc !== 0) && (type === 'b' || type === 'q')) return true;
                                break;
                            } else {
                                break;
                            }
                        }
                    }
                }
                
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const r = row + dr, c = col + dc;
                        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                            const piece = this.board[r][c];
                            if (piece && piece.toLowerCase() === 'k') {
                                if ((attackerColor === 'w' && piece === 'K') || (attackerColor === 'b' && piece === 'k')) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                return false;
            }
            
            isCheck(player = this.currentPlayer) {
                const kingPos = this.kingPositions[player];
                return this.isSquareAttacked(kingPos.row, kingPos.col, player === 'w' ? 'b' : 'w');
            }
            
            isCheckmate() {
                if (!this.isCheck()) return false;
                return this.generateAllMoves().length === 0;
            }
            
            isStalemate() {
                if (this.isCheck()) return false;
                return this.generateAllMoves().length === 0;
            }
            
            generateAllMoves() {
                const moves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && ((this.currentPlayer === 'w' && piece === piece.toUpperCase()) ||
                                     (this.currentPlayer === 'b' && piece === piece.toLowerCase()))) {
                            const pieceMoves = this.generatePieceMoves(r, c);
                            moves.push(...pieceMoves);
                        }
                    }
                }
                return moves;
            }
            
            generatePieceMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const isWhite = piece === piece.toUpperCase();
                const pieceType = piece.toLowerCase();
                const moves = [];
                
                switch (pieceType) {
                    case 'p': this.generatePawnMoves(row, col, isWhite, moves); break;
                    case 'n': this.generateKnightMoves(row, col, isWhite, moves); break;
                    case 'b': this.generateBishopMoves(row, col, isWhite, moves); break;
                    case 'r': this.generateRookMoves(row, col, isWhite, moves); break;
                    case 'q': this.generateQueenMoves(row, col, isWhite, moves); break;
                    case 'k': this.generateKingMoves(row, col, isWhite, moves); break;
                }
                
                return moves.filter(move => this.isMoveLegal({ from: { row, col }, to: move }));
            }
            
            isMoveLegal(move) {
                const piece = this.board[move.from.row][move.from.col];
                const targetPiece = this.board[move.to.row][move.to.col];
                const oldCastling = JSON.parse(JSON.stringify(this.castling));
                const oldEnPassant = this.enPassantTarget;
                const oldKingPos = { ...this.kingPositions[this.currentPlayer] };
                
                this.board[move.to.row][move.to.col] = piece;
                this.board[move.from.row][move.from.col] = '';
                
                if (piece.toLowerCase() === 'k') {
                    this.kingPositions[this.currentPlayer] = { row: move.to.row, col: move.to.col };
                }
                
                const inCheck = this.isCheck(this.currentPlayer);
                
                this.board[move.from.row][move.from.col] = piece;
                this.board[move.to.row][move.to.col] = targetPiece;
                this.kingPositions[this.currentPlayer] = oldKingPos;
                this.castling = oldCastling;
                this.enPassantTarget = oldEnPassant;
                
                return !inCheck;
            }
            
            generatePawnMoves(row, col, isWhite, moves) {
                const direction = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                
                if (row + direction >= 0 && row + direction < 8 && this.board[row + direction][col] === '') {
                    this.addPawnMove(row, col, row + direction, col, isWhite, moves);
                    
                    if (row === startRow && this.board[row + 2*direction][col] === '') {
                        this.addPawnMove(row, col, row + 2*direction, col, isWhite, moves);
                    }
                }
                
                for (let dcol of [-1, 1]) {
                    const newCol = col + dcol;
                    if (newCol >= 0 && newCol < 8 && row + direction >= 0 && row + direction < 8) {
                        const target = this.board[row + direction][newCol];
                        if (target && ((isWhite && target === target.toLowerCase()) || (!isWhite && target === target.toUpperCase()))) {
                            this.addPawnMove(row, col, row + direction, newCol, isWhite, moves);
                        }
                        
                        if (this.enPassantTarget && 
                            this.enPassantTarget.row === row + direction && 
                            this.enPassantTarget.col === newCol) {
                            moves.push({ row: row + direction, col: newCol, enPassant: true });
                        }
                    }
                }
            }
            
            addPawnMove(fromRow, fromCol, toRow, toCol, isWhite, moves) {
                const promotionRank = isWhite ? 0 : 7;
                if (toRow === promotionRank) {
                    ['q', 'r', 'b', 'n'].forEach(pieceType => {
                        moves.push({ row: toRow, col: toCol, promotion: pieceType });
                    });
                } else {
                    moves.push({ row: toRow, col: toCol });
                }
            }
            
            generateKnightMoves(row, col, isWhite, moves) {
                const offsets = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                for (let [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const target = this.board[newRow][newCol];
                        if (target === '' || 
                            (isWhite && target === target.toLowerCase()) || 
                            (!isWhite && target === target.toUpperCase())) {
                            moves.push({ row: newRow, col: newCol });
                        }
                    }
                }
            }
            
            generateSlidingMoves(row, col, isWhite, directions, moves) {
                for (let [dr, dc] of directions) {
                    for (let step = 1; step < 8; step++) {
                        const newRow = row + dr * step;
                        const newCol = col + dc * step;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        
                        const target = this.board[newRow][newCol];
                        if (target === '') {
                            moves.push({ row: newRow, col: newCol });
                        } else {
                            if ((isWhite && target === target.toLowerCase()) || (!isWhite && target === target.toUpperCase())) {
                                moves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                    }
                }
            }
            
            generateBishopMoves(row, col, isWhite, moves) {
                this.generateSlidingMoves(row, col, isWhite, [[-1,-1], [-1,1], [1,-1], [1,1]], moves);
            }
            
            generateRookMoves(row, col, isWhite, moves) {
                this.generateSlidingMoves(row, col, isWhite, [[-1,0], [1,0], [0,-1], [0,1]], moves);
            }
            
            generateQueenMoves(row, col, isWhite, moves) {
                this.generateSlidingMoves(row, col, isWhite, [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,-1], [1,1]], moves);
            }
            
            generateKingMoves(row, col, isWhite, moves) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            const target = this.board[newRow][newCol];
                            if (target === '' || 
                                (isWhite && target === target.toLowerCase()) || 
                                (!isWhite && target === target.toUpperCase())) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        }
                    }
                }
                
                if (!this.isCheck()) {
                    const kingRow = isWhite ? 7 : 0;
                    const castlingRights = this.castling[isWhite ? 'w' : 'b'];
                    
                    if (castlingRights.K) {
                        const empty = this.board[kingRow][5] === '' && this.board[kingRow][6] === '';
                        const notAttacked = !this.isSquareAttacked(kingRow, 5, isWhite ? 'b' : 'w') && 
                                           !this.isSquareAttacked(kingRow, 6, isWhite ? 'b' : 'w');
                        if (empty && notAttacked && this.board[kingRow][7] && 
                            ((isWhite && this.board[kingRow][7] === 'R') || (!isWhite && this.board[kingRow][7] === 'r'))) {
                            moves.push({ row: kingRow, col: 6, castling: 'K' });
                        }
                    }
                    
                    if (castlingRights.Q) {
                        const empty = this.board[kingRow][1] === '' && this.board[kingRow][2] === '' && this.board[kingRow][3] === '';
                        const notAttacked = !this.isSquareAttacked(kingRow, 2, isWhite ? 'b' : 'w') && 
                                           !this.isSquareAttacked(kingRow, 3, isWhite ? 'b' : 'w');
                        if (empty && notAttacked && this.board[kingRow][0] && 
                            ((isWhite && this.board[kingRow][0] === 'R') || (!isWhite && this.board[kingRow][0] === 'r'))) {
                            moves.push({ row: kingRow, col: 2, castling: 'Q' });
                        }
                    }
                }
            }
            
            makeMove(from, to, promotion = null) {
                const piece = this.board[from.row][from.col];
                const isWhite = piece === piece.toUpperCase();
                const pieceType = piece.toLowerCase();
                
                const capturedPiece = this.board[to.row][to.col];
                
                if (pieceType === 'p' || capturedPiece) {
                    this.halfMoveClock = 0;
                } else {
                    this.halfMoveClock++;
                }
                
                if (this.currentPlayer === 'b') {
                    this.fullMoveNumber++;
                }
                
                this.enPassantTarget = null;
                
                // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã
                if (pieceType === 'p') {
                    if (to.enPassant) {
                        this.board[from.row][to.col] = '';
                    }
                    
                    if (Math.abs(to.row - from.row) === 2) {
                        this.enPassantTarget = { row: (from.row + to.row) / 2, col: from.col };
                    }
                    
                    if (to.row === 0 || to.row === 7) {
                        const promotionPiece = promotion ? (isWhite ? promotion.toUpperCase() : promotion.toLowerCase()) : (isWhite ? 'Q' : 'q');
                        this.board[to.row][to.col] = promotionPiece;
                        this.board[from.row][from.col] = '';
                    } else {
                        this.board[to.row][to.col] = piece;
                        this.board[from.row][from.col] = '';
                    }
                } else if (pieceType === 'k') {
                    if (to.castling) {
                        if (to.col === 6) {
                            this.board[to.row][5] = this.board[to.row][7];
                            this.board[to.row][7] = '';
                        } else if (to.col === 2) {
                            this.board[to.row][3] = this.board[to.row][0];
                            this.board[to.row][0] = '';
                        }
                    }
                    
                    this.board[to.row][to.col] = piece;
                    this.board[from.row][from.col] = '';
                    
                    if (isWhite) {
                        this.castling.w.K = false;
                        this.castling.w.Q = false;
                    } else {
                        this.castling.b.K = false;
                        this.castling.b.Q = false;
                    }
                    
                    this.kingPositions[this.currentPlayer] = { row: to.row, col: to.col };
                } else {
                    this.board[to.row][to.col] = piece;
                    this.board[from.row][from.col] = '';
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤ –Ω–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É
                if (pieceType === 'r') {
                    if (isWhite) {
                        if (from.row === 7 && from.col === 0) this.castling.w.Q = false;
                        if (from.row === 7 && from.col === 7) this.castling.w.K = false;
                    } else {
                        if (from.row === 0 && from.col === 0) this.castling.b.Q = false;
                        if (from.row === 0 && from.col === 7) this.castling.b.K = false;
                    }
                }
                
                if (capturedPiece && capturedPiece.toLowerCase() === 'r') {
                    if (to.row === 7 && to.col === 0) this.castling.w.Q = false;
                    if (to.row === 7 && to.col === 7) this.castling.w.K = false;
                    if (to.row === 0 && to.col === 0) this.castling.b.Q = false;
                    if (to.row === 0 && to.col === 7) this.castling.b.K = false;
                }
                
                const moveNotation = this.formatMoveNotation(from, to, piece, capturedPiece, promotion);
                this.moveHistory.push({
                    from: { ...from },
                    to: { ...to },
                    piece,
                    captured: capturedPiece,
                    notation: moveNotation,
                    fen: this.getFEN()
                });
                
                this.positionHistory.push(this.getFENWithoutCounters());
                this.currentPlayer = this.currentPlayer === 'w' ? 'b' : 'w';
                this.lastMove = { from, to };
                
                return true;
            }
            
            formatMoveNotation(from, to, piece, captured, promotion) {
                const pieceType = piece.toLowerCase();
                let notation = '';
                
                if (pieceType === 'p') {
                    if (captured || to.enPassant) {
                        notation += String.fromCharCode(97 + from.col);
                        notation += 'x';
                    }
                    notation += String.fromCharCode(97 + to.col) + (8 - to.row);
                    if (promotion) {
                        notation += '=' + promotion.toUpperCase();
                    }
                } else {
                    const symbols = { 'k': 'K', 'q': 'Q', 'r': 'R', 'b': 'B', 'n': 'N' };
                    notation += symbols[pieceType];
                    
                    if (captured) notation += 'x';
                    notation += String.fromCharCode(97 + to.col) + (8 - to.row);
                    
                    if (to.castling) {
                        notation = to.col === 6 ? 'O-O' : 'O-O-O';
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —à–∞—Ö/–º–∞—Ç
                const gameCopy = new ChessGame();
                gameCopy.board = this.board.map(row => [...row]);
                gameCopy.currentPlayer = this.currentPlayer === 'w' ? 'b' : 'w';
                gameCopy.kingPositions = JSON.parse(JSON.stringify(this.kingPositions));
                gameCopy.castling = JSON.parse(JSON.stringify(this.castling));
                
                if (gameCopy.isCheckmate()) {
                    notation += '#';
                } else if (gameCopy.isCheck()) {
                    notation += '+';
                }
                
                return notation;
            }
            
            undoMove() {
                if (this.moveHistory.length === 0) return false;
                
                const lastMove = this.moveHistory[this.moveHistory.length - 1];
                this.moveHistory.pop();
                this.positionHistory.pop();
                
                if (this.moveHistory.length > 0) {
                    const prevFEN = this.moveHistory[this.moveHistory.length - 1].fen;
                    this.loadFromFEN(prevFEN);
                    this.currentPlayer = this.moveHistory[this.moveHistory.length - 1].fen.split(' ')[1];
                } else {
                    this.initBoard();
                }
                
                this.lastMove = this.moveHistory.length > 0 ? this.moveHistory[this.moveHistory.length - 1] : null;
                return true;
            }
            
            loadFromFEN(fen) {
                const parts = fen.split(' ');
                const position = parts[0];
                this.currentPlayer = parts[1];
                const castling = parts[2];
                const enPassant = parts[3];
                
                this.board = Array(8).fill().map(() => Array(8).fill(''));
                
                const rows = position.split('/');
                for (let r = 0; r < 8; r++) {
                    let col = 0;
                    for (let char of rows[r]) {
                        if (isNaN(char)) {
                            this.board[r][col] = char;
                            if (char.toLowerCase() === 'k') {
                                this.kingPositions[char === 'K' ? 'w' : 'b'] = { row: r, col };
                            }
                            col++;
                        } else {
                            col += parseInt(char);
                        }
                    }
                }
                
                this.castling = { w: { K: false, Q: false }, b: { K: false, Q: false } };
                if (castling.includes('K')) this.castling.w.K = true;
                if (castling.includes('Q')) this.castling.w.Q = true;
                if (castling.includes('k')) this.castling.b.K = true;
                if (castling.includes('q')) this.castling.b.Q = true;
                
                if (enPassant !== '-') {
                    const col = enPassant.charCodeAt(0) - 97;
                    const row = 8 - parseInt(enPassant[1]);
                    this.enPassantTarget = { row, col };
                } else {
                    this.enPassantTarget = null;
                }
            }
        }
        
        // ---------- UI ----------
        class ChessUI {
            constructor() {
                this.game = new ChessGame();
                this.engine = new PowerfulEngine();
                this.flipped = false;
                this.selectedSquare = null;
                this.legalMoves = [];
                this.pendingPromotion = null;
                
                this.boardElement = document.getElementById('chessboard');
                this.fenDisplay = document.getElementById('fenDisplay');
                this.moveHistoryElement = document.getElementById('moveHistory');
                this.turnIcon = document.getElementById('turnIcon');
                this.turnText = document.getElementById('turnText');
                this.checkDisplay = document.getElementById('checkDisplay');
                this.errorDisplay = document.getElementById('errorDisplay');
                this.loadingDisplay = document.getElementById('loadingDisplay');
                
                this.evalBar = document.getElementById('evalBar');
                this.evalValue = document.getElementById('evalValue');
                this.evalDetails = document.getElementById('evalDetails');
                
                this.initEventListeners();
                this.render();
                this.updateTurnDisplay();
                this.updateFEN();
                
                // –ê–Ω–∞–ª–∏–∑ —Å—Ç–∞—Ä—Ç–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
                setTimeout(() => this.analyzePosition(), 200);
            }
            
            initEventListeners() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('flipBoardBtn').addEventListener('click', () => this.flipBoard());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
                document.getElementById('analyzeBtn').addEventListener('click', () => this.analyzePosition(true));
                
                this.boardElement.addEventListener('click', (e) => {
                    const square = e.target.closest('.square');
                    if (!square) return;
                    
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    this.handleSquareClick(row, col);
                });
            }
            
            handleSquareClick(row, col) {
                if (this.pendingPromotion) return;
                
                const piece = this.game.board[row][col];
                const currentPlayerColor = this.game.currentPlayer === 'w' ? 'white' : 'black';
                
                if (this.selectedSquare) {
                    const move = this.legalMoves.find(m => m.row === row && m.col === col);
                    
                    if (move) {
                        this.makeMove(this.selectedSquare, { row, col }, move);
                        this.selectedSquare = null;
                        this.legalMoves = [];
                    } else {
                        if (piece && this.isPieceColor(piece, currentPlayerColor)) {
                            this.selectedSquare = { row, col };
                            this.legalMoves = this.game.generatePieceMoves(row, col);
                        } else {
                            this.selectedSquare = null;
                            this.legalMoves = [];
                        }
                    }
                } else {
                    if (piece && this.isPieceColor(piece, currentPlayerColor)) {
                        this.selectedSquare = { row, col };
                        this.legalMoves = this.game.generatePieceMoves(row, col);
                    }
                }
                
                this.render();
            }
            
            isPieceColor(piece, color) {
                return (color === 'white' && piece === piece.toUpperCase()) ||
                       (color === 'black' && piece === piece.toLowerCase());
            }
            
            makeMove(from, to, moveData) {
                const piece = this.game.board[from.row][from.col];
                if (piece.toLowerCase() === 'p' && (to.row === 0 || to.row === 7)) {
                    this.pendingPromotion = { from, to, moveData };
                    this.showPromotionDialog(to.row === 0 ? 'white' : 'black');
                    return;
                }
                
                const success = this.game.makeMove(from, to, moveData.promotion || 'q');
                
                if (success) {
                    this.selectedSquare = null;
                    this.legalMoves = [];
                    this.render();
                    this.updateTurnDisplay();
                    this.updateFEN();
                    this.updateMoveHistory();
                    this.checkGameEnd();
                    this.analyzePosition();
                }
            }
            
            showPromotionDialog(color) {
                const pieces = ['q', 'r', 'b', 'n'];
                const symbols = { 'q': '‚ôï', 'r': '‚ôñ', 'b': '‚ôó', 'n': '‚ôò' };
                
                const dialog = document.createElement('div');
                dialog.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #28363f;
                    padding: 20px;
                    border-radius: 16px;
                    box-shadow: 0 15px 40px rgba(0,0,0,0.8);
                    z-index: 1000;
                    border: 3px solid #ffd966;
                `;
                
                dialog.innerHTML = `
                    <div style="color: #ffd966; margin-bottom: 15px;">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É:</div>
                    <div style="display: flex; gap: 15px;">
                        ${pieces.map(p => `
                            <div class="promotion-piece" data-piece="${p}" style="
                                font-size: 3em;
                                cursor: pointer;
                                padding: 5px 10px;
                                background: #1e2e38;
                                border-radius: 8px;
                                border: 2px solid #3f5562;
                            ">${symbols[p]}</div>
                        `).join('')}
                    </div>
                `;
                
                document.body.appendChild(dialog);
                
                dialog.querySelectorAll('.promotion-piece').forEach(el => {
                    el.addEventListener('mouseenter', () => {
                        el.style.background = '#3f5562';
                        el.style.borderColor = '#ffd966';
                    });
                    el.addEventListener('mouseleave', () => {
                        el.style.background = '#1e2e38';
                        el.style.borderColor = '#3f5562';
                    });
                    
                    el.addEventListener('click', () => {
                        const piece = el.dataset.piece;
                        const { from, to } = this.pendingPromotion;
                        
                        this.game.makeMove(from, to, piece);
                        this.pendingPromotion = null;
                        document.body.removeChild(dialog);
                        
                        this.selectedSquare = null;
                        this.legalMoves = [];
                        this.render();
                        this.updateTurnDisplay();
                        this.updateFEN();
                        this.updateMoveHistory();
                        this.checkGameEnd();
                        this.analyzePosition();
                    });
                });
            }
            
            checkGameEnd() {
                if (this.game.isCheckmate()) {
                    const winner = this.game.currentPlayer === 'w' ? '–ß–µ—Ä–Ω—ã–µ' : '–ë–µ–ª—ã–µ';
                    this.showMessage(`–ú–∞—Ç! ${winner} –ø–æ–±–µ–¥–∏–ª–∏!`);
                    this.checkDisplay.style.display = 'none';
                } else if (this.game.isStalemate()) {
                    this.showMessage('–ü–∞—Ç! –ù–∏—á—å—è!');
                    this.checkDisplay.style.display = 'none';
                } else if (this.game.isCheck()) {
                    this.checkDisplay.style.display = 'block';
                } else {
                    this.checkDisplay.style.display = 'none';
                }
            }
            
            showMessage(text) {
                const msg = document.createElement('div');
                msg.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #ffd966;
                    color: #1e2e38;
                    padding: 10px 20px;
                    border-radius: 30px;
                    font-weight: bold;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
                    z-index: 2000;
                `;
                msg.textContent = text;
                document.body.appendChild(msg);
                
                setTimeout(() => document.body.removeChild(msg), 3000);
            }
            
            updateTurnDisplay() {
                const isWhiteTurn = this.game.currentPlayer === 'w';
                this.turnIcon.textContent = isWhiteTurn ? '‚ö™' : '‚ö´';
                this.turnText.textContent = isWhiteTurn ? '–•–æ–¥ –±–µ–ª—ã—Ö' : '–•–æ–¥ —á–µ—Ä–Ω—ã—Ö';
            }
            
            updateFEN() {
                this.fenDisplay.textContent = this.game.getFEN();
            }
            
            updateMoveHistory() {
                this.moveHistoryElement.innerHTML = '';
                
                for (let i = 0; i < this.game.moveHistory.length; i += 2) {
                    const moveNumber = Math.floor(i / 2) + 1;
                    
                    const numDiv = document.createElement('div');
                    numDiv.className = 'move-number';
                    numDiv.textContent = moveNumber + '.';
                    
                    const whiteDiv = document.createElement('div');
                    whiteDiv.className = 'white-move';
                    whiteDiv.textContent = this.game.moveHistory[i]?.notation || '';
                    whiteDiv.addEventListener('click', () => this.jumpToMove(i));
                    
                    const blackDiv = document.createElement('div');
                    blackDiv.className = 'black-move';
                    blackDiv.textContent = this.game.moveHistory[i+1]?.notation || '';
                    if (this.game.moveHistory[i+1]) {
                        blackDiv.addEventListener('click', () => this.jumpToMove(i+1));
                    }
                    
                    this.moveHistoryElement.appendChild(numDiv);
                    this.moveHistoryElement.appendChild(whiteDiv);
                    this.moveHistoryElement.appendChild(blackDiv);
                }
            }
            
            jumpToMove(index) {
                if (index < 0 || index >= this.game.moveHistory.length) return;
                
                const targetFEN = this.game.moveHistory[index].fen;
                this.game.loadFromFEN(targetFEN);
                this.game.moveHistory = this.game.moveHistory.slice(0, index + 1);
                this.game.positionHistory = this.game.positionHistory.slice(0, index + 2);
                this.game.lastMove = this.game.moveHistory[index];
                // –í–ê–ñ–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—á–µ—Ä–µ–¥–∏ —Ö–æ–¥–∞
                this.game.currentPlayer = this.game.moveHistory[index].fen.split(' ')[1];
                
                this.selectedSquare = null;
                this.legalMoves = [];
                this.render();
                this.updateTurnDisplay();
                this.updateFEN();
                this.updateMoveHistory();
                this.checkGameEnd();
                this.analyzePosition();
            }
            
            render() {
                this.boardElement.innerHTML = '';
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const displayRow = this.flipped ? 7 - r : r;
                        const displayCol = this.flipped ? 7 - c : c;
                        
                        const square = document.createElement('div');
                        square.className = `square ${(displayRow + displayCol) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = displayRow;
                        square.dataset.col = displayCol;
                        
                        const coord = document.createElement('span');
                        coord.className = 'coordinate';
                        coord.textContent = String.fromCharCode(97 + displayCol) + (8 - displayRow);
                        square.appendChild(coord);
                        
                        const piece = this.game.board[displayRow][displayCol];
                        if (piece) {
                            const pieceSpan = document.createElement('span');
                            pieceSpan.className = `piece ${piece === piece.toUpperCase() ? 'white' : 'black'}`;
                            pieceSpan.textContent = pieceSymbols[piece];
                            square.appendChild(pieceSpan);
                        }
                        
                        if (this.selectedSquare && this.selectedSquare.row === displayRow && this.selectedSquare.col === displayCol) {
                            square.classList.add('selected');
                        }
                        
                        if (this.game.lastMove) {
                            if (this.game.lastMove.from.row === displayRow && this.game.lastMove.from.col === displayCol) {
                                square.classList.add('last-move-from');
                            }
                            if (this.game.lastMove.to.row === displayRow && this.game.lastMove.to.col === displayCol) {
                                square.classList.add('last-move-to');
                            }
                        }
                        
                        if (this.game.isCheck()) {
                            const kingPos = this.game.kingPositions[this.game.currentPlayer];
                            if (kingPos.row === displayRow && kingPos.col === displayCol) {
                                square.classList.add('checked');
                            }
                        }
                        
                        if (this.legalMoves.length > 0) {
                            for (let move of this.legalMoves) {
                                if (move.row === displayRow && move.col === displayCol) {
                                    if (this.game.board[displayRow][displayCol]) {
                                        square.classList.add('legal-capture');
                                    } else {
                                        square.classList.add('legal-move');
                                    }
                                    break;
                                }
                            }
                        }
                        
                        this.boardElement.appendChild(square);
                    }
                }
            }
            
            newGame() {
                this.game = new ChessGame();
                this.selectedSquare = null;
                this.legalMoves = [];
                this.pendingPromotion = null;
                this.flipped = false;
                
                this.render();
                this.updateTurnDisplay();
                this.updateFEN();
                this.updateMoveHistory();
                this.checkGameEnd();
                this.analyzePosition();
            }
            
            flipBoard() {
                this.flipped = !this.flipped;
                this.render();
            }
            
            undoMove() {
                this.game.undoMove();
                this.selectedSquare = null;
                this.legalMoves = [];
                this.pendingPromotion = null;
                
                this.render();
                this.updateTurnDisplay();
                this.updateFEN();
                this.updateMoveHistory();
                this.checkGameEnd();
                this.analyzePosition();
            }
            
            analyzePosition(forceDeep = false) {
                this.loadingDisplay.style.display = 'flex';
                
                setTimeout(() => {
                    try {
                        // –£–°–ò–õ–ï–ù–ù–ê–Ø –û–¶–ï–ù–ö–ê: –≥–ª—É–±–∂–µ –∏ —Ç–æ—á–Ω–µ–µ
                        const score = this.engine.evaluateBoard(this.game.board);
                        
                        // –î–æ–±–∞–≤–ª—è–µ–º –¥–∏–Ω–∞–º–∏–∫—É –æ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–∞
                        let finalScore = score;
                        
                        // –£—á–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø—Ä–∏ —Ö–æ–¥–µ
                        if (this.game.currentPlayer === 'w') {
                            finalScore += 0.1; // –Ω–µ–±–æ–ª—å—à–æ–π –±–æ–Ω—É—Å –∑–∞ –æ—á–µ—Ä–µ–¥—å
                        } else {
                            finalScore -= 0.1;
                        }
                        
                        // –®–∫–∞–ª–∞ –æ—Ç -3 –¥–æ +3
                        let percent = 50 + finalScore * 10;
                        percent = Math.min(95, Math.max(5, percent));
                        this.evalBar.style.width = percent + '%';
                        
                        this.evalValue.textContent = (finalScore > 0 ? '+' : '') + finalScore.toFixed(2);
                        
                        // –ü–æ–∏—Å–∫ –ª—É—á—à–µ–≥–æ —Ö–æ–¥–∞ (–≥–ª—É–±–∏–Ω–∞ 3 –¥–ª—è –±—ã—Å—Ç—Ä–æ—Ç—ã)
                        const bestMove = this.engine.findBestMove(this.game, forceDeep ? 4 : 3);
                        
                        if (bestMove) {
                            const from = String.fromCharCode(97 + bestMove.from.col) + (8 - bestMove.from.row);
                            const to = String.fromCharCode(97 + bestMove.to.col) + (8 - bestMove.to.row);
                            this.evalDetails.innerHTML = `
                                –ì–ª—É–±–∏–Ω–∞: ${forceDeep ? 4 : 3}<br>
                                –õ—É—á—à–∏–π —Ö–æ–¥: ${from} ‚Üí ${to} ${bestMove.promotion ? '=' + bestMove.promotion.toUpperCase() : ''}<br>
                                –û—Ü–µ–Ω–∫–∞: ${bestMove.score ? bestMove.score.toFixed(2) : '‚Äî'}
                            `;
                        } else {
                            if (this.game.isCheckmate()) {
                                this.evalDetails.innerHTML = `–ú–∞—Ç. –ü–æ–±–µ–¥–∞ ${this.game.currentPlayer === 'w' ? '—á–µ—Ä–Ω—ã—Ö' : '–±–µ–ª—ã—Ö'}.`;
                            } else if (this.game.isStalemate()) {
                                this.evalDetails.innerHTML = `–ü–∞—Ç. –ù–∏—á—å—è.`;
                            } else {
                                this.evalDetails.innerHTML = `–ù–µ—Ç –ª–µ–≥–∞–ª—å–Ω—ã—Ö —Ö–æ–¥–æ–≤.`;
                            }
                        }
                        
                        this.errorDisplay.style.display = 'none';
                    } catch (e) {
                        console.error('Engine error:', e);
                        this.errorDisplay.style.display = 'block';
                        this.errorDisplay.textContent = '–û—à–∏–±–∫–∞ –¥–≤–∏–∂–∫–∞';
                    } finally {
                        this.loadingDisplay.style.display = 'none';
                    }
                }, 10);
            }
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            window.ui = new ChessUI();
        });
    })();
</script>
</body>
</html>
