<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–î–µ–±—é—Ç–Ω—ã–π —Ç—Ä–µ–Ω–∞–∂—ë—Ä –ø–æ PGN</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background: #1a2a32;
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px;
        }
        
        .container {
            max-width: 1400px;
            width: 100%;
            background: #2d3f4b;
            border-radius: 24px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            text-align: center;
            color: #ffd966;
            margin: 0 0 15px 0;
            font-size: 2em;
        }
        
        .main-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .board-section {
            flex: 2;
            min-width: 500px;
        }
        
        .control-section {
            flex: 1;
            min-width: 300px;
            background: #28363f;
            border-radius: 16px;
            padding: 20px;
            border: 1px solid #3f5562;
        }
        
        .board-container {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            border: 3px solid #c9a76b;
            max-width: 600px;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            aspect-ratio: 1;
            background: #deb887;
        }
        
        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: min(5vw, 2.8em);
            cursor: pointer;
            position: relative;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
        }
        
        .square.light {
            background-color: #f0d9b5;
        }
        
        .square.dark {
            background-color: #b58863;
        }
        
        .square.selected {
            background-color: #b6d7a8 !important;
            box-shadow: inset 0 0 0 3px #2e7d32;
        }
        
        .square.last-move {
            background-color: rgba(255, 255, 0, 0.4) !important;
        }
        
        .square.hint {
            background-color: #c4e0c4 !important;
            box-shadow: inset 0 0 0 3px #4caf50;
        }
        
        .square.wrong-move {
            background-color: #f4a7a7 !important;
            box-shadow: inset 0 0 0 3px #c62828;
            animation: shake 0.3s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .square.legal-move::after {
            content: '';
            position: absolute;
            width: 20%;
            height: 20%;
            background: rgba(0, 80, 0, 0.4);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .coordinate {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.6em;
            color: rgba(0,0,0,0.3);
        }
        
        .piece.white {
            color: #ffffff;
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
        }
        
        .piece.black {
            color: #222222;
            filter: drop-shadow(2px 2px 2px rgba(255,255,255,0.2));
        }
        
        .upload-area {
            background: #1e2e38;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            border: 2px dashed #ffd966;
        }
        
        .upload-label {
            background: #ffd966;
            color: #1e2e38;
            padding: 12px 20px;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            display: inline-block;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        
        .upload-label:hover {
            background: #ffe082;
            transform: translateY(-2px);
        }
        
        .file-name {
            color: #a0b8c5;
            font-size: 0.9em;
            margin-top: 10px;
            word-break: break-all;
        }
        
        .side-selector {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .side-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            background: #3f5562;
            color: white;
            transition: all 0.2s;
            border-bottom: 3px solid #1e2e38;
        }
        
        .side-btn.active {
            background: #ffd966;
            color: #1e2e38;
            border-bottom-color: #b68b40;
        }
        
        .side-btn.white.active {
            background: #f0f0f0;
            color: #1a2a32;
        }
        
        .side-btn.black.active {
            background: #2c3e50;
            color: white;
        }
        
        .theory-info {
            background: #1e2e38;
            border-radius: 12px;
            padding: 15px;
            margin: 20px 0;
            border-left: 4px solid #ffd966;
        }
        
        .theory-move {
            font-size: 1.3em;
            font-weight: bold;
            color: #ffd966;
            margin-bottom: 10px;
        }
        
        .theory-line {
            color: #a0b8c5;
            font-size: 0.95em;
            max-height: 100px;
            overflow-y: auto;
            padding: 5px;
            background: #1a2a32;
            border-radius: 8px;
        }
        
        .progress-bar {
            height: 10px;
            background: #1a2a32;
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #4caf50;
            width: 0%;
            transition: width 0.3s;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 20px;
            font-weight: 600;
            cursor: pointer;
            background: #3f5562;
            color: white;
            transition: all 0.2s;
            border-bottom: 2px solid #1e2e38;
        }
        
        .btn:hover:not(:disabled) {
            background: #4f6b7c;
            transform: translateY(-2px);
        }
        
        .btn.primary {
            background: #ffd966;
            color: #1e2e38;
            border-bottom-color: #b68b40;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .message {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
            display: none;
        }
        
        .message.error {
            background: #c62828;
            color: white;
            display: block;
        }
        
        .message.success {
            background: #2e7d32;
            color: white;
            display: block;
        }
        
        .message.hint {
            background: #ffd966;
            color: #1a2a32;
            display: block;
        }
        
        .fen-box {
            background: #1a2a32;
            padding: 8px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.8em;
            color: #a0b8c5;
            margin: 10px 0;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>‚ôüÔ∏è –î–µ–±—é—Ç–Ω—ã–π —Ç—Ä–µ–Ω–∞–∂—ë—Ä –ø–æ PGN ‚ôüÔ∏è</h1>
    
    <div class="main-panel">
        <div class="board-section">
            <div class="board-container">
                <div class="board" id="chessboard"></div>
            </div>
        </div>
        
        <div class="control-section">
            <div class="upload-area">
                <label for="pgnFile" class="upload-label">üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å PGN</label>
                <input type="file" id="pgnFile" accept=".pgn,.txt" style="display: none;">
                <div class="file-name" id="fileName">–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω</div>
            </div>
            
            <div class="side-selector">
                <button id="sideWhite" class="side-btn white active">‚ö™ –ò–≥—Ä–∞—Ç—å –±–µ–ª—ã–º–∏</button>
                <button id="sideBlack" class="side-btn black">‚ö´ –ò–≥—Ä–∞—Ç—å —á—ë—Ä–Ω—ã–º–∏</button>
            </div>
            
            <div class="theory-info">
                <div class="theory-move" id="theoryMove">–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏</div>
                <div class="theory-line" id="theoryLine">‚Äî</div>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div id="messageBox" class="message"></div>
            
            <div class="fen-box" id="fenDisplay">rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1</div>
            
            <div class="button-group">
                <button class="btn" id="resetBtn">üîÑ –°–±—Ä–æ—Å</button>
                <button class="btn" id="hintBtn">üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
                <button class="btn primary" id="nextBtn">‚è© –°–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥</button>
            </div>
        </div>
    </div>
</div>

<script>
    (function() {
        // –°–∏–º–≤–æ–ª—ã —Ñ–∏–≥—É—Ä
        const pieceSymbols = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };
        
        // ---------- –®–ê–•–ú–ê–¢–ù–ê–Ø –õ–û–ì–ò–ö–ê (–ü–û–õ–ù–ê–Ø) ----------
        class ChessGame {
            constructor() {
                this.board = Array(8).fill().map(() => Array(8).fill(''));
                this.currentPlayer = 'w';
                this.castling = { w: { K: true, Q: true }, b: { K: true, Q: true } };
                this.enPassantTarget = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                this.moveHistory = [];
                this.kingPositions = { w: { row: 7, col: 4 }, b: { row: 0, col: 4 } };
                
                this.initBoard();
            }
            
            initBoard() {
                // –ü–µ—à–∫–∏
                for (let col = 0; col < 8; col++) {
                    this.board[6][col] = 'P';
                    this.board[1][col] = 'p';
                }
                
                // –õ–∞–¥—å–∏
                this.board[7][0] = 'R'; this.board[7][7] = 'R';
                this.board[0][0] = 'r'; this.board[0][7] = 'r';
                
                // –ö–æ–Ω–∏
                this.board[7][1] = 'N'; this.board[7][6] = 'N';
                this.board[0][1] = 'n'; this.board[0][6] = 'n';
                
                // –°–ª–æ–Ω—ã
                this.board[7][2] = 'B'; this.board[7][5] = 'B';
                this.board[0][2] = 'b'; this.board[0][5] = 'b';
                
                // –§–µ—Ä–∑–∏
                this.board[7][3] = 'Q';
                this.board[0][3] = 'q';
                
                // –ö–æ—Ä–æ–ª–∏
                this.board[7][4] = 'K';
                this.board[0][4] = 'k';
                
                this.kingPositions = { w: { row: 7, col: 4 }, b: { row: 0, col: 4 } };
                this.currentPlayer = 'w';
                this.castling = { w: { K: true, Q: true }, b: { K: true, Q: true } };
                this.enPassantTarget = null;
                this.moveHistory = [];
            }
            
            getFEN() {
                let fen = '';
                for (let r = 0; r < 8; r++) {
                    let empty = 0;
                    for (let c = 0; c < 8; c++) {
                        if (this.board[r][c] === '') {
                            empty++;
                        } else {
                            if (empty > 0) {
                                fen += empty;
                                empty = 0;
                            }
                            fen += this.board[r][c];
                        }
                    }
                    if (empty > 0) fen += empty;
                    if (r < 7) fen += '/';
                }
                
                fen += this.currentPlayer === 'w' ? ' w ' : ' b ';
                
                let castlingStr = '';
                if (this.castling.w.K) castlingStr += 'K';
                if (this.castling.w.Q) castlingStr += 'Q';
                if (this.castling.b.K) castlingStr += 'k';
                if (this.castling.b.Q) castlingStr += 'q';
                fen += castlingStr || '-';
                
                if (this.enPassantTarget) {
                    fen += ` ${String.fromCharCode(97 + this.enPassantTarget.col)}${8 - this.enPassantTarget.row}`;
                } else {
                    fen += ' -';
                }
                
                fen += ` ${this.halfMoveClock} ${this.fullMoveNumber}`;
                return fen;
            }
            
            isSquareAttacked(row, col, attackerColor) {
                // –ü–µ—à–∫–∏
                const pawnDir = attackerColor === 'w' ? 1 : -1;
                if (attackerColor === 'w') {
                    if (row+1 < 8 && col-1 >= 0 && this.board[row+1][col-1] === 'P') return true;
                    if (row+1 < 8 && col+1 < 8 && this.board[row+1][col+1] === 'P') return true;
                } else {
                    if (row-1 >= 0 && col-1 >= 0 && this.board[row-1][col-1] === 'p') return true;
                    if (row-1 >= 0 && col+1 < 8 && this.board[row-1][col+1] === 'p') return true;
                }
                
                // –ö–æ–Ω–∏
                const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                for (let [dr, dc] of knightMoves) {
                    const r = row + dr, c = col + dc;
                    if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                        const piece = this.board[r][c];
                        if (piece && piece.toLowerCase() === 'n' && 
                            ((attackerColor === 'w' && piece === 'N') || (attackerColor === 'b' && piece === 'n'))) {
                            return true;
                        }
                    }
                }
                
                // –°–ª–æ–Ω—ã, –ª–∞–¥—å–∏, —Ñ–µ—Ä–∑–∏
                const directions = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,-1], [1,1]];
                for (let [dr, dc] of directions) {
                    for (let step = 1; step < 8; step++) {
                        const r = row + dr * step;
                        const c = col + dc * step;
                        if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
                        
                        const piece = this.board[r][c];
                        if (piece) {
                            const isWhitePiece = piece === piece.toUpperCase();
                            if ((attackerColor === 'w' && isWhitePiece) || (attackerColor === 'b' && !isWhitePiece)) {
                                const type = piece.toLowerCase();
                                if ((dr === 0 || dc === 0) && (type === 'r' || type === 'q')) return true;
                                if ((dr !== 0 && dc !== 0) && (type === 'b' || type === 'q')) return true;
                                break;
                            } else {
                                break;
                            }
                        }
                    }
                }
                
                // –ö–æ—Ä–æ–ª—å
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const r = row + dr, c = col + dc;
                        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                            const piece = this.board[r][c];
                            if (piece && piece.toLowerCase() === 'k' && 
                                ((attackerColor === 'w' && piece === 'K') || (attackerColor === 'b' && piece === 'k'))) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            isCheck(player = this.currentPlayer) {
                const kingPos = this.kingPositions[player];
                return this.isSquareAttacked(kingPos.row, kingPos.col, player === 'w' ? 'b' : 'w');
            }
            
            generateAllMoves() {
                const moves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && ((this.currentPlayer === 'w' && piece === piece.toUpperCase()) ||
                                     (this.currentPlayer === 'b' && piece === piece.toLowerCase()))) {
                            const pieceMoves = this.generatePieceMoves(r, c);
                            moves.push(...pieceMoves.map(m => ({ from: { row: r, col: c }, to: m })));
                        }
                    }
                }
                return moves;
            }
            
            generatePieceMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const isWhite = piece === piece.toUpperCase();
                const pieceType = piece.toLowerCase();
                const moves = [];
                
                switch (pieceType) {
                    case 'p': this.generatePawnMoves(row, col, isWhite, moves); break;
                    case 'n': this.generateKnightMoves(row, col, isWhite, moves); break;
                    case 'b': this.generateBishopMoves(row, col, isWhite, moves); break;
                    case 'r': this.generateRookMoves(row, col, isWhite, moves); break;
                    case 'q': this.generateQueenMoves(row, col, isWhite, moves); break;
                    case 'k': this.generateKingMoves(row, col, isWhite, moves); break;
                }
                
                return moves.filter(move => this.isMoveLegal({ from: { row, col }, to: move }));
            }
            
            isMoveLegal(move) {
                const piece = this.board[move.from.row][move.from.col];
                const targetPiece = this.board[move.to.row][move.to.col];
                const oldCastling = JSON.parse(JSON.stringify(this.castling));
                const oldEnPassant = this.enPassantTarget;
                const oldKingPos = { ...this.kingPositions[this.currentPlayer] };
                
                this.board[move.to.row][move.to.col] = piece;
                this.board[move.from.row][move.from.col] = '';
                
                if (piece.toLowerCase() === 'k') {
                    this.kingPositions[this.currentPlayer] = { row: move.to.row, col: move.to.col };
                }
                
                const inCheck = this.isCheck(this.currentPlayer);
                
                this.board[move.from.row][move.from.col] = piece;
                this.board[move.to.row][move.to.col] = targetPiece;
                this.kingPositions[this.currentPlayer] = oldKingPos;
                this.castling = oldCastling;
                this.enPassantTarget = oldEnPassant;
                
                return !inCheck;
            }
            
            generatePawnMoves(row, col, isWhite, moves) {
                const direction = isWhite ? -1 : 1;
                const startRow = isWhite ? 6 : 1;
                
                if (row + direction >= 0 && row + direction < 8 && this.board[row + direction][col] === '') {
                    moves.push({ row: row + direction, col });
                    
                    if (row === startRow && this.board[row + 2*direction][col] === '') {
                        moves.push({ row: row + 2*direction, col });
                    }
                }
                
                for (let dcol of [-1, 1]) {
                    const newCol = col + dcol;
                    if (newCol >= 0 && newCol < 8 && row + direction >= 0 && row + direction < 8) {
                        const target = this.board[row + direction][newCol];
                        if (target && ((isWhite && target === target.toLowerCase()) || (!isWhite && target === target.toUpperCase()))) {
                            moves.push({ row: row + direction, col: newCol });
                        }
                        
                        if (this.enPassantTarget && 
                            this.enPassantTarget.row === row + direction && 
                            this.enPassantTarget.col === newCol) {
                            moves.push({ row: row + direction, col: newCol, enPassant: true });
                        }
                    }
                }
            }
            
            generateKnightMoves(row, col, isWhite, moves) {
                const offsets = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                for (let [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        const target = this.board[newRow][newCol];
                        if (target === '' || 
                            (isWhite && target === target.toLowerCase()) || 
                            (!isWhite && target === target.toUpperCase())) {
                            moves.push({ row: newRow, col: newCol });
                        }
                    }
                }
            }
            
            generateSlidingMoves(row, col, isWhite, directions, moves) {
                for (let [dr, dc] of directions) {
                    for (let step = 1; step < 8; step++) {
                        const newRow = row + dr * step;
                        const newCol = col + dc * step;
                        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
                        
                        const target = this.board[newRow][newCol];
                        if (target === '') {
                            moves.push({ row: newRow, col: newCol });
                        } else {
                            if ((isWhite && target === target.toLowerCase()) || (!isWhite && target === target.toUpperCase())) {
                                moves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                    }
                }
            }
            
            generateBishopMoves(row, col, isWhite, moves) {
                this.generateSlidingMoves(row, col, isWhite, [[-1,-1], [-1,1], [1,-1], [1,1]], moves);
            }
            
            generateRookMoves(row, col, isWhite, moves) {
                this.generateSlidingMoves(row, col, isWhite, [[-1,0], [1,0], [0,-1], [0,1]], moves);
            }
            
            generateQueenMoves(row, col, isWhite, moves) {
                this.generateSlidingMoves(row, col, isWhite, [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,-1], [1,1]], moves);
            }
            
            generateKingMoves(row, col, isWhite, moves) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            const target = this.board[newRow][newCol];
                            if (target === '' || 
                                (isWhite && target === target.toLowerCase()) || 
                                (!isWhite && target === target.toUpperCase())) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        }
                    }
                }
                
                // –†–æ–∫–∏—Ä–æ–≤–∫–∞ (–ò–°–ü–†–ê–í–õ–ï–ù–û!)
                if (!this.isCheck()) {
                    const kingRow = isWhite ? 7 : 0;
                    const castlingRights = this.castling[isWhite ? 'w' : 'b'];
                    
                    // –ö–æ—Ä–æ—Ç–∫–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞ (K)
                    if (castlingRights.K) {
                        const empty = this.board[kingRow][5] === '' && this.board[kingRow][6] === '';
                        const notAttacked = !this.isSquareAttacked(kingRow, 5, isWhite ? 'b' : 'w') && 
                                           !this.isSquareAttacked(kingRow, 6, isWhite ? 'b' : 'w');
                        if (empty && notAttacked && this.board[kingRow][7] && 
                            ((isWhite && this.board[kingRow][7] === 'R') || (!isWhite && this.board[kingRow][7] === 'r'))) {
                            moves.push({ row: kingRow, col: 6, castling: 'K' });
                        }
                    }
                    
                    // –î–ª–∏–Ω–Ω–∞—è —Ä–æ–∫–∏—Ä–æ–≤–∫–∞ (Q)
                    if (castlingRights.Q) {
                        const empty = this.board[kingRow][1] === '' && this.board[kingRow][2] === '' && this.board[kingRow][3] === '';
                        const notAttacked = !this.isSquareAttacked(kingRow, 2, isWhite ? 'b' : 'w') && 
                                           !this.isSquareAttacked(kingRow, 3, isWhite ? 'b' : 'w');
                        if (empty && notAttacked && this.board[kingRow][0] && 
                            ((isWhite && this.board[kingRow][0] === 'R') || (!isWhite && this.board[kingRow][0] === 'r'))) {
                            moves.push({ row: kingRow, col: 2, castling: 'Q' });
                        }
                    }
                }
            }
            
            makeMove(move) {
                const from = move.from;
                const to = move.to;
                const piece = this.board[from.row][from.col];
                if (!piece) return false;
                
                const isWhite = piece === piece.toUpperCase();
                const pieceType = piece.toLowerCase();
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏
                const moveNotation = this.squareToAlgebraic(from) + '-' + this.squareToAlgebraic(to);
                this.moveHistory.push(moveNotation);
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Ö–æ–¥–æ–≤
                if (pieceType === 'p') {
                    if (to.enPassant) {
                        this.board[from.row][to.col] = '';
                    }
                    
                    if (Math.abs(to.row - from.row) === 2) {
                        this.enPassantTarget = { row: (from.row + to.row) / 2, col: from.col };
                    } else {
                        this.enPassantTarget = null;
                    }
                    
                    if (to.row === 0 || to.row === 7) {
                        // –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –≤ —Ñ–µ—Ä–∑—è (–¥–ª—è —Ç—Ä–µ–Ω–∞–∂—ë—Ä–∞ –≤—Å–µ–≥–¥–∞ —Ñ–µ—Ä–∑—å)
                        this.board[to.row][to.col] = isWhite ? 'Q' : 'q';
                        this.board[from.row][from.col] = '';
                    } else {
                        this.board[to.row][to.col] = piece;
                        this.board[from.row][from.col] = '';
                    }
                } else if (pieceType === 'k') {
                    if (to.castling) {
                        if (to.col === 6) { // –ö–æ—Ä–æ—Ç–∫–∞—è
                            this.board[to.row][5] = this.board[to.row][7];
                            this.board[to.row][7] = '';
                        } else if (to.col === 2) { // –î–ª–∏–Ω–Ω–∞—è
                            this.board[to.row][3] = this.board[to.row][0];
                            this.board[to.row][0] = '';
                        }
                    }
                    
                    this.board[to.row][to.col] = piece;
                    this.board[from.row][from.col] = '';
                    
                    if (isWhite) {
                        this.castling.w.K = false;
                        this.castling.w.Q = false;
                    } else {
                        this.castling.b.K = false;
                        this.castling.b.Q = false;
                    }
                    
                    this.kingPositions[this.currentPlayer] = { row: to.row, col: to.col };
                    this.enPassantTarget = null;
                } else {
                    this.board[to.row][to.col] = piece;
                    this.board[from.row][from.col] = '';
                    this.enPassantTarget = null;
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∞–≤ –Ω–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫—É –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –ª–∞–¥—å–∏
                if (pieceType === 'r') {
                    if (isWhite) {
                        if (from.row === 7 && from.col === 0) this.castling.w.Q = false;
                        if (from.row === 7 && from.col === 7) this.castling.w.K = false;
                    } else {
                        if (from.row === 0 && from.col === 0) this.castling.b.Q = false;
                        if (from.row === 0 && from.col === 7) this.castling.b.K = false;
                    }
                }
                
                // –°–º–µ–Ω–∞ –∏–≥—Ä–æ–∫–∞
                this.currentPlayer = this.currentPlayer === 'w' ? 'b' : 'w';
                if (this.currentPlayer === 'w') this.fullMoveNumber++;
                
                return true;
            }
            
            squareToAlgebraic(sq) {
                return String.fromCharCode(97 + sq.col) + (8 - sq.row);
            }
            
            algebraicToSquare(alg) {
                return {
                    col: alg.charCodeAt(0) - 97,
                    row: 8 - parseInt(alg[1])
                };
            }
            
            loadFromFEN(fen) {
                const parts = fen.split(' ');
                const position = parts[0];
                this.currentPlayer = parts[1];
                const castling = parts[2];
                const enPassant = parts[3];
                
                this.board = Array(8).fill().map(() => Array(8).fill(''));
                
                const rows = position.split('/');
                for (let r = 0; r < 8; r++) {
                    let col = 0;
                    for (let char of rows[r]) {
                        if (isNaN(char)) {
                            this.board[r][col] = char;
                            if (char.toLowerCase() === 'k') {
                                this.kingPositions[char === 'K' ? 'w' : 'b'] = { row: r, col };
                            }
                            col++;
                        } else {
                            col += parseInt(char);
                        }
                    }
                }
                
                this.castling = { w: { K: false, Q: false }, b: { K: false, Q: false } };
                if (castling.includes('K')) this.castling.w.K = true;
                if (castling.includes('Q')) this.castling.w.Q = true;
                if (castling.includes('k')) this.castling.b.K = true;
                if (castling.includes('q')) this.castling.b.Q = true;
                
                if (enPassant !== '-') {
                    const col = enPassant.charCodeAt(0) - 97;
                    const row = 8 - parseInt(enPassant[1]);
                    this.enPassantTarget = { row, col };
                } else {
                    this.enPassantTarget = null;
                }
            }
        }
        
        // ---------- –ü–ê–†–°–ï–† PGN ----------
        function parsePGN(pgnText) {
            const moves = [];
            const lines = pgnText.split('\n');
            
            for (let line of lines) {
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∏ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
                if (line.startsWith('[') || line.trim() === '') continue;
                
                // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ö–æ–¥—ã
                const tokens = line.split(/\s+/);
                for (let token of tokens) {
                    // –£–±–∏—Ä–∞–µ–º –Ω–æ–º–µ—Ä–∞ —Ö–æ–¥–æ–≤ (1., 2. –∏ —Ç.–¥.)
                    if (token.match(/^\d+\./)) {
                        token = token.replace(/^\d+\./, '');
                    }
                    
                    // –£–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–≥—Ä—ã (1-0, 0-1, 1/2-1/2)
                    if (token.match(/^[01]-[01]|1\/2-1\/2$/)) continue;
                    
                    // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ä–µ–∞–ª—å–Ω—ã–µ —Ö–æ–¥—ã
                    if (token && !token.includes('$') && token.length > 1) {
                        // –£–±–∏—Ä–∞–µ–º —Å–∏–º–≤–æ–ª—ã —à–∞—Ö/–º–∞—Ç
                        token = token.replace(/[+#]/g, '');
                        if (token) moves.push(token);
                    }
                }
            }
            
            return moves;
        }
        
        // ---------- UI ----------
        class TrainerUI {
            constructor() {
                this.game = new ChessGame();
                this.flipped = false;
                this.selectedSquare = null;
                this.legalMoves = [];
                this.theoryMoves = []; // –º–∞—Å—Å–∏–≤ —Ö–æ–¥–æ–≤ –∏–∑ PGN –≤ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–æ–π –Ω–æ—Ç–∞—Ü–∏–∏
                self.currentTheoryIndex = 0;
                self.playerSide = 'w'; // 'w' –∏–ª–∏ 'b'
                self.lastMoveSquares = null;
                
                this.boardElement = document.getElementById('chessboard');
                this.fenDisplay = document.getElementById('fenDisplay');
                this.theoryMoveEl = document.getElementById('theoryMove');
                this.theoryLineEl = document.getElementById('theoryLine');
                this.progressFill = document.getElementById('progressFill');
                this.messageBox = document.getElementById('messageBox');
                this.fileNameEl = document.getElementById('fileName');
                
                this.initEventListeners();
                this.render();
                this.updateFEN();
            }
            
            initEventListeners() {
                document.getElementById('pgnFile').addEventListener('change', (e) => this.loadPGN(e));
                document.getElementById('sideWhite').addEventListener('click', () => this.setSide('w'));
                document.getElementById('sideBlack').addEventListener('click', () => this.setSide('b'));
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
                document.getElementById('nextBtn').addEventListener('click', () => this.nextMove());
                
                this.boardElement.addEventListener('click', (e) => {
                    const square = e.target.closest('.square');
                    if (!square) return;
                    
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    this.handleSquareClick(row, col);
                });
            }
            
            setSide(side) {
                self.playerSide = side;
                document.getElementById('sideWhite').classList.remove('active');
                document.getElementById('sideBlack').classList.remove('active');
                document.getElementById(side === 'w' ? 'sideWhite' : 'sideBlack').classList.add('active');
                this.reset();
            }
            
            loadPGN(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                this.fileNameEl.textContent = file.name;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const pgnText = e.target.result;
                    self.theoryMoves = parsePGN(pgnText);
                    
                    if (self.theoryMoves.length === 0) {
                        this.showMessage('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ö–æ–¥—ã –≤ PGN', 'error');
                        return;
                    }
                    
                    this.showMessage(`–ó–∞–≥—Ä—É–∂–µ–Ω–æ ${self.theoryMoves.length} —Ö–æ–¥–æ–≤`, 'success');
                    this.reset();
                };
                reader.readAsText(file);
            }
            
            reset() {
                this.game = new ChessGame();
                self.currentTheoryIndex = 0;
                this.selectedSquare = null;
                this.legalMoves = [];
                this.lastMoveSquares = null;
                this.render();
                this.updateFEN();
                this.updateTheoryDisplay();
                this.hideMessage();
            }
            
            handleSquareClick(row, col) {
                const piece = this.game.board[row][col];
                const isPlayerTurn = this.game.currentPlayer === self.playerSide;
                
                if (!isPlayerTurn) {
                    this.showMessage('–°–µ–π—á–∞—Å —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞', 'hint');
                    return;
                }
                
                if (this.selectedSquare) {
                    const move = this.legalMoves.find(m => m.row === row && m.col === col);
                    
                    if (move) {
                        // –ü—Ä–æ–±—É–µ–º —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥
                        this.tryMove({ from: this.selectedSquare, to: move });
                        this.selectedSquare = null;
                        this.legalMoves = [];
                    } else {
                        if (piece && this.isPieceColor(piece, self.playerSide)) {
                            this.selectedSquare = { row, col };
                            this.legalMoves = this.game.generatePieceMoves(row, col);
                        } else {
                            this.selectedSquare = null;
                            this.legalMoves = [];
                        }
                    }
                } else {
                    if (piece && this.isPieceColor(piece, self.playerSide)) {
                        this.selectedSquare = { row, col };
                        this.legalMoves = this.game.generatePieceMoves(row, col);
                    }
                }
                
                this.render();
            }
            
            tryMove(move) {
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ö–æ–¥ –≤ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫—É—é –Ω–æ—Ç–∞—Ü–∏—é –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å —Ç–µ–æ—Ä–∏–µ–π
                const piece = this.game.board[move.from.row][move.from.col];
                const isWhite = piece === piece.toUpperCase();
                const fromSquare = this.game.squareToAlgebraic(move.from);
                const toSquare = this.game.squareToAlgebraic(move.to);
                
                let moveAlgebraic = '';
                
                // –ü—Ä–æ—Å—Ç–∞—è –Ω–æ—Ç–∞—Ü–∏—è (—É–ø—Ä–æ—â—ë–Ω–Ω–æ, –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è)
                if (piece.toLowerCase() === 'p') {
                    if (this.game.board[move.to.row][move.to.col] || move.to.enPassant) {
                        moveAlgebraic = fromSquare[0] + 'x' + toSquare;
                    } else {
                        moveAlgebraic = toSquare;
                    }
                } else {
                    const pieceChar = piece.toUpperCase();
                    if (this.game.board[move.to.row][move.to.col]) {
                        moveAlgebraic = pieceChar + 'x' + toSquare;
                    } else {
                        moveAlgebraic = pieceChar + toSquare;
                    }
                }
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫–∏
                if (piece.toLowerCase() === 'k' && Math.abs(move.to.col - move.from.col) === 2) {
                    moveAlgebraic = move.to.col === 6 ? 'O-O' : 'O-O-O';
                }
                
                // –ü–æ–ª—É—á–∞–µ–º –æ–∂–∏–¥–∞–µ–º—ã–π —Ö–æ–¥ –∏–∑ —Ç–µ–æ—Ä–∏–∏
                const expectedMove = self.theoryMoves[self.currentTheoryIndex];
                
                if (!expectedMove) {
                    this.showMessage('–¢–µ–æ—Ä–∏—è –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å!', 'success');
                    return;
                }
                
                // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º (—É–ø—Ä–æ—â—ë–Ω–Ω–æ - –ø–æ –∫–æ–Ω–µ—á–Ω–æ–º—É –ø–æ–ª—é)
                const expectedTo = expectedMove.replace(/[^a-h1-8]/g, '').slice(-2);
                const actualTo = toSquare;
                
                if (actualTo === expectedTo || moveAlgebraic === expectedMove) {
                    // –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ö–æ–¥
                    this.game.makeMove(move);
                    self.currentTheoryIndex++;
                    this.lastMoveSquares = move;
                    this.selectedSquare = null;
                    this.legalMoves = [];
                    this.render();
                    this.updateFEN();
                    this.updateTheoryDisplay();
                    this.hideMessage();
                    
                    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–µ–ª–∞–µ–º —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –∏–∑ —Ç–µ–æ—Ä–∏–∏
                    setTimeout(() => this.makeOpponentMove(), 300);
                } else {
                    // –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ö–æ–¥
                    this.render();
                    setTimeout(() => {
                        const squareEl = this.boardElement.querySelector(`[data-row="${move.to.row}"][data-col="${move.to.col}"]`);
                        if (squareEl) {
                            squareEl.classList.add('wrong-move');
                            setTimeout(() => squareEl.classList.remove('wrong-move'), 500);
                        }
                    }, 10);
                    
                    const expectedFrom = expectedMove.replace(/[^a-h1-8]/g, '').slice(0, 2);
                    this.showMessage(`–û—à–∏–±–∫–∞! –û–∂–∏–¥–∞–ª—Å—è —Ö–æ–¥ ${expectedMove} (${expectedFrom} ‚Üí ${expectedTo})`, 'error');
                }
            }
            
            makeOpponentMove() {
                if (self.currentTheoryIndex >= self.theoryMoves.length) return;
                
                const isOpponentTurn = this.game.currentPlayer !== self.playerSide;
                if (!isOpponentTurn) return;
                
                const expectedMove = self.theoryMoves[self.currentTheoryIndex];
                if (!expectedMove) return;
                
                // –ü–∞—Ä—Å–∏–º —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ (—É–ø—Ä–æ—â—ë–Ω–Ω–æ)
                const toSquare = expectedMove.replace(/[^a-h1-8]/g, '').slice(-2);
                if (toSquare.length !== 2) return;
                
                const to = this.game.algebraicToSquare(toSquare);
                
                // –ò—â–µ–º —Ñ–∏–≥—É—Ä—É, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –ø–æ–π—Ç–∏ –Ω–∞ —ç—Ç–æ –ø–æ–ª–µ
                const allMoves = this.game.generateAllMoves();
                const move = allMoves.find(m => m.to.row === to.row && m.to.col === to.col);
                
                if (move) {
                    this.game.makeMove(move);
                    self.currentTheoryIndex++;
                    this.lastMoveSquares = move;
                    this.render();
                    this.updateFEN();
                    this.updateTheoryDisplay();
                    this.hideMessage();
                } else {
                    console.warn('–ù–µ –Ω–∞–π–¥–µ–Ω —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞:', expectedMove);
                }
            }
            
            isPieceColor(piece, color) {
                return (color === 'w' && piece === piece.toUpperCase()) ||
                       (color === 'b' && piece === piece.toLowerCase());
            }
            
            showHint() {
                if (self.currentTheoryIndex >= self.theoryMoves.length) {
                    this.showMessage('–¢–µ–æ—Ä–∏—è –∑–∞–∫–æ–Ω—á–µ–Ω–∞', 'hint');
                    return;
                }
                
                const expectedMove = self.theoryMoves[self.currentTheoryIndex];
                const toSquare = expectedMove.replace(/[^a-h1-8]/g, '').slice(-2);
                
                if (toSquare.length === 2) {
                    const to = this.game.algebraicToSquare(toSquare);
                    
                    // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –ø–æ–ª–µ
                    this.render();
                    setTimeout(() => {
                        const squareEl = this.boardElement.querySelector(`[data-row="${to.row}"][data-col="${to.col}"]`);
                        if (squareEl) {
                            squareEl.classList.add('hint');
                            setTimeout(() => squareEl.classList.remove('hint'), 2000);
                        }
                    }, 10);
                    
                    this.showMessage(`–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ö–æ–¥: ${expectedMove}`, 'hint');
                }
            }
            
            nextMove() {
                if (self.currentTheoryIndex >= self.theoryMoves.length) {
                    this.showMessage('–¢–µ–æ—Ä–∏—è –∑–∞–∫–æ–Ω—á–µ–Ω–∞', 'hint');
                    return;
                }
                
                // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –¥–µ–ª–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥ –ø–æ —Ç–µ–æ—Ä–∏–∏
                if (this.game.currentPlayer !== self.playerSide) {
                    this.makeOpponentMove();
                } else {
                    // –ï—Å–ª–∏ —Å–µ–π—á–∞—Å —Ö–æ–¥ –∏–≥—Ä–æ–∫–∞ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É
                    this.showHint();
                }
            }
            
            updateTheoryDisplay() {
                const total = self.theoryMoves.length;
                const current = self.currentTheoryIndex;
                
                if (total === 0) {
                    this.theoryMoveEl.textContent = '–ó–∞–≥—Ä—É–∑–∏—Ç–µ PGN —Ñ–∞–π–ª';
                    this.theoryLineEl.textContent = '‚Äî';
                    this.progressFill.style.width = '0%';
                    return;
                }
                
                const progress = (current / total) * 100;
                this.progressFill.style.width = progress + '%';
                
                if (current < total) {
                    const nextMove = self.theoryMoves[current];
                    this.theoryMoveEl.textContent = `–°–ª–µ–¥—É—é—â–∏–π —Ö–æ–¥: ${nextMove}`;
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ª–∏–Ω–∏—é
                    const start = Math.max(0, current - 2);
                    const end = Math.min(total, current + 5);
                    const line = self.theoryMoves.slice(start, end).map((m, i) => {
                        const idx = start + i;
                        return idx === current ? `<b style="color:#ffd966">${m}</b>` : m;
                    }).join(' ');
                    
                    this.theoryLineEl.innerHTML = line;
                } else {
                    this.theoryMoveEl.textContent = '–¢–µ–æ—Ä–∏—è –ø—Ä–æ–π–¥–µ–Ω–∞!';
                    this.theoryLineEl.innerHTML = self.theoryMoves.join(' ');
                }
            }
            
            showMessage(text, type = 'info') {
                this.messageBox.className = 'message';
                this.messageBox.classList.add(type);
                this.messageBox.textContent = text;
                this.messageBox.style.display = 'block';
            }
            
            hideMessage() {
                this.messageBox.style.display = 'none';
            }
            
            updateFEN() {
                this.fenDisplay.textContent = this.game.getFEN();
            }
            
            render() {
                this.boardElement.innerHTML = '';
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const displayRow = this.flipped ? 7 - r : r;
                        const displayCol = this.flipped ? 7 - c : c;
                        
                        const square = document.createElement('div');
                        square.className = `square ${(displayRow + displayCol) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = displayRow;
                        square.dataset.col = displayCol;
                        
                        const coord = document.createElement('span');
                        coord.className = 'coordinate';
                        coord.textContent = String.fromCharCode(97 + displayCol) + (8 - displayRow);
                        square.appendChild(coord);
                        
                        const piece = this.game.board[displayRow][displayCol];
                        if (piece) {
                            const pieceSpan = document.createElement('span');
                            pieceSpan.className = `piece ${piece === piece.toUpperCase() ? 'white' : 'black'}`;
                            pieceSpan.textContent = pieceSymbols[piece];
                            square.appendChild(pieceSpan);
                        }
                        
                        if (this.selectedSquare && this.selectedSquare.row === displayRow && this.selectedSquare.col === displayCol) {
                            square.classList.add('selected');
                        }
                        
                        if (this.lastMoveSquares) {
                            if (this.lastMoveSquares.from.row === displayRow && this.lastMoveSquares.from.col === displayCol) {
                                square.classList.add('last-move');
                            }
                            if (this.lastMoveSquares.to.row === displayRow && this.lastMoveSquares.to.col === displayCol) {
                                square.classList.add('last-move');
                            }
                        }
                        
                        if (this.legalMoves.length > 0) {
                            for (let move of this.legalMoves) {
                                if (move.row === displayRow && move.col === displayCol) {
                                    if (this.game.board[displayRow][displayCol]) {
                                        square.classList.add('legal-capture');
                                    } else {
                                        square.classList.add('legal-move');
                                    }
                                    break;
                                }
                            }
                        }
                        
                        this.boardElement.appendChild(square);
                    }
                }
            }
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            window.trainer = new TrainerUI();
        });
    })();
</script>
</body>
</html>
