<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Бесплатная шахматная доска анализа</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c32 0%, #2a5a4a 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: #2d2d2d;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        
        .board-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            border: 3px solid #4a4a4a;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        
        .square {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        
        .square.light {
            background-color: #f0d9b5;
        }
        
        .square.dark {
            background-color: #b58863;
        }
        
        .square.selected {
            background-color: #7b9f7b !important;
            box-shadow: inset 0 0 0 3px #4caf50;
        }
        
        .square.possible-move {
            position: relative;
        }
        
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 255, 0, 0.4);
            border-radius: 50%;
        }
        
        .square.possible-capture::after {
            content: '';
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 0, 0, 0.4);
            border-radius: 50%;
        }
        
        .square.last-move {
            background-color: #afa27b !important;
        }
        
        .square:active {
            transform: scale(0.95);
        }
        
        .info-panel {
            background: #3a3a3a;
            border-radius: 15px;
            padding: 20px;
            color: white;
            min-width: 250px;
        }
        
        .status {
            background: #4a4a4a;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }
        
        .moves-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 10px;
            background: #333;
            border-radius: 10px;
        }
        
        .move-item {
            padding: 8px 12px;
            margin: 4px 0;
            background: #444;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            transition: background 0.2s;
        }
        
        .move-item:hover {
            background: #555;
        }
        
        .move-item.white {
            border-left: 3px solid #fff;
        }
        
        .move-item.black {
            border-left: 3px solid #000;
        }
        
        .buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        button {
            padding: 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button.reset {
            background: #f44336;
        }
        
        button.reset:hover {
            background: #da190b;
        }
        
        button.analysis {
            background: #2196F3;
        }
        
        button.analysis:hover {
            background: #0b7dda;
        }
        
        .notation {
            font-family: 'Courier New', monospace;
            color: #ffd700;
        }
        
        .captured-pieces {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            min-height: 40px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
        }
        
        @media (max-width: 768px) {
            .chess-board {
                grid-template-columns: repeat(8, 50px);
                grid-template-rows: repeat(8, 50px);
            }
            
            .square {
                width: 50px;
                height: 50px;
                font-size: 36px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board-container">
            <div class="chess-board" id="chessBoard"></div>
            
            <div class="info-panel">
                <div class="status" id="gameStatus">Ход белых</div>
                
                <div class="captured-pieces" id="capturedWhitePieces">
                    <span style="color: #aaa;">Съеденные черные:</span>
                </div>
                <div class="captured-pieces" id="capturedBlackPieces">
                    <span style="color: #aaa;">Съеденные белые:</span>
                </div>
                
                <div class="moves-list" id="movesList">
                    <div style="text-align: center; color: #888;">История ходов</div>
                </div>
                
                <div class="buttons">
                    <button onclick="chessGame.resetGame()" class="reset">Новая игра</button>
                    <button onclick="chessGame.undoMove()" class="analysis">Отмена хода</button>
                    <button onclick="chessGame.toggleAnalysis()" class="analysis">Режим анализа</button>
                    <button onclick="chessGame.flipBoard()" class="analysis">Повернуть доску</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ChessGame {
            constructor() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.analysisMode = false;
                this.boardFlipped = false;
                this.lastMove = null;
                this.castlingRights = {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                };
                this.enPassantTarget = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                
                this.initBoard();
            }
            
            createInitialBoard() {
                return [
                    ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
                    ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
                    ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
                ];
            }
            
            initBoard() {
                this.renderBoard();
                this.updateStatus();
            }
            
            renderBoard() {
                const boardElement = document.getElementById('chessBoard');
                boardElement.innerHTML = '';
                
                let boardToRender = this.board;
                if (this.boardFlipped) {
                    boardToRender = this.flipBoardArray(this.board);
                }
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const actualRow = this.boardFlipped ? 7 - row : row;
                        const actualCol = this.boardFlipped ? 7 - col : col;
                        
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = actualRow;
                        square.dataset.col = actualCol;
                        
                        const piece = boardToRender[row][col];
                        if (piece) {
                            square.textContent = piece;
                        }
                        
                        if (this.selectedSquare && 
                            this.selectedSquare.row === actualRow && 
                            this.selectedSquare.col === actualCol) {
                            square.classList.add('selected');
                        }
                        
                        if (this.lastMove) {
                            if ((actualRow === this.lastMove.from.row && actualCol === this.lastMove.from.col) ||
                                (actualRow === this.lastMove.to.row && actualCol === this.lastMove.to.col)) {
                                square.classList.add('last-move');
                            }
                        }
                        
                        this.possibleMoves.forEach(move => {
                            if (move.to.row === actualRow && move.to.col === actualCol) {
                                if (this.board[actualRow][actualCol]) {
                                    square.classList.add('possible-capture');
                                } else {
                                    square.classList.add('possible-move');
                                }
                            }
                        });
                        
                        square.addEventListener('click', () => this.handleSquareClick(actualRow, actualCol));
                        boardElement.appendChild(square);
                    }
                }
            }
            
            flipBoardArray(board) {
                const flipped = [];
                for (let i = 0; i < 8; i++) {
                    flipped[i] = [];
                    for (let j = 0; j < 8; j++) {
                        flipped[i][j] = board[7 - i][7 - j];
                    }
                }
                return flipped;
            }
            
            handleSquareClick(row, col) {
                const piece = this.board[row][col];
                
                if (this.selectedSquare) {
                    const move = this.possibleMoves.find(m => m.to.row === row && m.to.col === col);
                    
                    if (move) {
                        this.makeMove(move);
                        this.selectedSquare = null;
                        this.possibleMoves = [];
                    } else {
                        if (piece && this.getPieceColor(piece) === this.currentPlayer) {
                            this.selectedSquare = { row, col };
                            this.possibleMoves = this.getValidMoves(row, col);
                        } else {
                            this.selectedSquare = null;
                            this.possibleMoves = [];
                        }
                    }
                } else {
                    if (piece && this.getPieceColor(piece) === this.currentPlayer) {
                        this.selectedSquare = { row, col };
                        this.possibleMoves = this.getValidMoves(row, col);
                    }
                }
                
                this.renderBoard();
            }
            
            getPieceColor(piece) {
                if (!piece) return null;
                const whitePieces = ['♔', '♕', '♖', '♗', '♘', '♙'];
                const blackPieces = ['♚', '♛', '♜', '♝', '♞', '♟'];
                if (whitePieces.includes(piece)) return 'white';
                if (blackPieces.includes(piece)) return 'black';
                return null;
            }
            
            getValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const color = this.getPieceColor(piece);
                if (color !== this.currentPlayer) return [];
                
                const moves = [];
                
                switch(piece) {
                    case '♙': // Белая пешка
                        this.getPawnMoves(row, col, 'white', moves);
                        break;
                    case '♟': // Черная пешка
                        this.getPawnMoves(row, col, 'black', moves);
                        break;
                    case '♖':
                    case '♜':
                        this.getRookMoves(row, col, moves);
                        break;
                    case '♘':
                    case '♞':
                        this.getKnightMoves(row, col, moves);
                        break;
                    case '♗':
                    case '♝':
                        this.getBishopMoves(row, col, moves);
                        break;
                    case '♕':
                    case '♛':
                        this.getQueenMoves(row, col, moves);
                        break;
                    case '♔':
                    case '♚':
                        this.getKingMoves(row, col, color, moves);
                        break;
                }
                
                // Фильтруем ходы, которые оставляют короля под шахом
                return moves.filter(move => !this.wouldBeInCheck(row, col, move.to.row, move.to.col, color));
            }
            
            getPawnMoves(row, col, color, moves) {
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                // Движение вперед
                if (this.isInBounds(row + direction, col) && !this.board[row + direction][col]) {
                    moves.push({ from: { row, col }, to: { row: row + direction, col } });
                    
                    // Движение на две клетки с начальной позиции
                    if (row === startRow && !this.board[row + 2 * direction][col]) {
                        moves.push({ from: { row, col }, to: { row: row + 2 * direction, col } });
                    }
                }
                
                // Взятие фигур
                [-1, 1].forEach(offset => {
                    const newCol = col + offset;
                    if (this.isInBounds(row + direction, newCol)) {
                        const targetPiece = this.board[row + direction][newCol];
                        if (targetPiece && this.getPieceColor(targetPiece) !== color) {
                            moves.push({ from: { row, col }, to: { row: row + direction, col: newCol } });
                        }
                        
                        // Взятие на проходе
                        if (this.enPassantTarget && 
                            this.enPassantTarget.row === row + direction && 
                            this.enPassantTarget.col === newCol) {
                            moves.push({ 
                                from: { row, col }, 
                                to: { row: row + direction, col: newCol },
                                enPassant: true 
                            });
                        }
                    }
                });
            }
            
            getRookMoves(row, col, moves) {
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                this.getSlidingMoves(row, col, directions, moves);
            }
            
            getBishopMoves(row, col, moves) {
                const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                this.getSlidingMoves(row, col, directions, moves);
            }
            
            getQueenMoves(row, col, moves) {
                const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                this.getSlidingMoves(row, col, directions, moves);
            }
            
            getKnightMoves(row, col, moves) {
                const knightMoves = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                
                const pieceColor = this.getPieceColor(this.board[row][col]);
                
                knightMoves.forEach(([rowOffset, colOffset]) => {
                    const newRow = row + rowOffset;
                    const newCol = col + colOffset;
                    
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || this.getPieceColor(targetPiece) !== pieceColor) {
                            moves.push({ from: { row, col }, to: { row: newRow, col: newCol } });
                        }
                    }
                });
            }
            
            getKingMoves(row, col, color, moves) {
                const kingMoves = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1], [0, 1],
                    [1, -1], [1, 0], [1, 1]
                ];
                
                kingMoves.forEach(([rowOffset, colOffset]) => {
                    const newRow = row + rowOffset;
                    const newCol = col + colOffset;
                    
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || this.getPieceColor(targetPiece) !== color) {
                            moves.push({ from: { row, col }, to: { row: newRow, col: newCol } });
                        }
                    }
                });
                
                // Рокировка
                if (color === 'white' && row === 7 && col === 4) {
                    if (this.castlingRights.white.kingside && 
                        !this.board[7][5] && !this.board[7][6] &&
                        !this.isSquareAttacked(7, 4, 'white') &&
                        !this.isSquareAttacked(7, 5, 'white') &&
                        !this.isSquareAttacked(7, 6, 'white')) {
                        moves.push({ from: { row, col }, to: { row: 7, col: 6 }, castle: 'kingside' });
                    }
                    if (this.castlingRights.white.queenside && 
                        !this.board[7][3] && !this.board[7][2] && !this.board[7][1] &&
                        !this.isSquareAttacked(7, 4, 'white') &&
                        !this.isSquareAttacked(7, 3, 'white') &&
                        !this.isSquareAttacked(7, 2, 'white')) {
                        moves.push({ from: { row, col }, to: { row: 7, col: 2 }, castle: 'queenside' });
                    }
                }
                
                if (color === 'black' && row === 0 && col === 4) {
                    if (this.castlingRights.black.kingside && 
                        !this.board[0][5] && !this.board[0][6] &&
                        !this.isSquareAttacked(0, 4, 'black') &&
                        !this.isSquareAttacked(0, 5, 'black') &&
                        !this.isSquareAttacked(0, 6, 'black')) {
                        moves.push({ from: { row, col }, to: { row: 0, col: 6 }, castle: 'kingside' });
                    }
                    if (this.castlingRights.black.queenside && 
                        !this.board[0][3] && !this.board[0][2] && !this.board[0][1] &&
                        !this.isSquareAttacked(0, 4, 'black') &&
                        !this.isSquareAttacked(0, 3, 'black') &&
                        !this.isSquareAttacked(0, 2, 'black')) {
                        moves.push({ from: { row, col }, to: { row: 0, col: 2 }, castle: 'queenside' });
                    }
                }
            }
            
            getSlidingMoves(row, col, directions, moves) {
                const pieceColor = this.getPieceColor(this.board[row][col]);
                
                directions.forEach(([rowDir, colDir]) => {
                    let newRow = row + rowDir;
                    let newCol = col + colDir;
                    
                    while (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        
                        if (!targetPiece) {
                            moves.push({ from: { row, col }, to: { row: newRow, col: newCol } });
                        } else {
                            if (this.getPieceColor(targetPiece) !== pieceColor) {
                                moves.push({ from: { row, col }, to: { row: newRow, col: newCol } });
                            }
                            break;
                        }
                        
                        newRow += rowDir;
                        newCol += colDir;
                    }
                });
            }
            
            isSquareAttacked(row, col, defendingColor) {
                const attackingColor = defendingColor === 'white' ? 'black' : 'white';
                
                // Проверка атак пешек
                const pawnDirection = defendingColor === 'white' ? -1 : 1;
                [-1, 1].forEach(offset => {
                    const attackRow = row + pawnDirection;
                    const attackCol = col + offset;
                    if (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece && this.getPieceColor(piece) === attackingColor) {
                            if ((defendingColor === 'white' && piece === '♟') ||
                                (defendingColor === 'black' && piece === '♙')) {
                                return true;
                            }
                        }
                    }
                });
                
                // Проверка атак коней
                const knightMoves = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                
                for (const [rowOffset, colOffset] of knightMoves) {
                    const attackRow = row + rowOffset;
                    const attackCol = col + colOffset;
                    if (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece && this.getPieceColor(piece) === attackingColor) {
                            if (piece === '♘' || piece === '♞') {
                                return true;
                            }
                        }
                    }
                }
                
                // Проверка атак слонов и ферзя
                const bishopDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                for (const [rowDir, colDir] of bishopDirections) {
                    let attackRow = row + rowDir;
                    let attackCol = col + colDir;
                    
                    while (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece) {
                            if (this.getPieceColor(piece) === attackingColor) {
                                if (piece === '♗' || piece === '♝' || piece === '♕' || piece === '♛') {
                                    return true;
                                }
                            }
                            break;
                        }
                        attackRow += rowDir;
                        attackCol += colDir;
                    }
                }
                
                // Проверка атак ладей и ферзя
                const rookDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                for (const [rowDir, colDir] of rookDirections) {
                    let attackRow = row + rowDir;
                    let attackCol = col + colDir;
                    
                    while (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece) {
                            if (this.getPieceColor(piece) === attackingColor) {
                                if (piece === '♖' || piece === '♜' || piece === '♕' || piece === '♛') {
                                    return true;
                                }
                            }
                            break;
                        }
                        attackRow += rowDir;
                        attackCol += colDir;
                    }
                }
                
                // Проверка атак короля
                const kingMoves = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1], [0, 1],
                    [1, -1], [1, 0], [1, 1]
                ];
                
                for (const [rowOffset, colOffset] of kingMoves) {
                    const attackRow = row + rowOffset;
                    const attackCol = col + colOffset;
                    if (this.isInBounds(attackRow, attackCol)) {
                        const piece = this.board[attackRow][attackCol];
                        if (piece && this.getPieceColor(piece) === attackingColor) {
                            if (piece === '♔' || piece === '♚') {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
                // Сохраняем текущее состояние
                const piece = this.board[fromRow][fromCol];
                const targetPiece = this.board[toRow][toCol];
                const enPassantTarget = this.enPassantTarget;
                const capturedEnPassant = this.board[toRow][toCol] === '' && 
                                         piece === (color === 'white' ? '♙' : '♟') &&
                                         toCol !== fromCol;
                
                // Временный ход
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = '';
                
                if (capturedEnPassant) {
                    this.board[fromRow][toCol] = '';
                }
                
                // Находим позицию короля
                let kingRow, kingCol;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = this.board[r][c];
                        if (p && this.getPieceColor(p) === color) {
                            if (p === '♔' || p === '♚') {
                                kingRow = r;
                                kingCol = c;
                                break;
                            }
                        }
                    }
                }
                
                // Проверяем, под шахом ли король
                const inCheck = this.isSquareAttacked(kingRow, kingCol, color);
                
                // Отменяем временный ход
                this.board[fromRow][fromCol] = piece;
                this.board[toRow][toCol] = targetPiece;
                
                if (capturedEnPassant) {
                    this.board[fromRow][toCol] = color === 'white' ? '♟' : '♙';
                }
                
                this.enPassantTarget = enPassantTarget;
                
                return inCheck;
            }
            
            isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            makeMove(move) {
                const piece = this.board[move.from.row][move.from.col];
                const capturedPiece = this.board[move.to.row][move.to.col];
                const pieceColor = this.getPieceColor(piece);
                
                // Сохраняем состояние для отмены
                const moveRecord = {
                    piece,
                    from: { ...move.from },
                    to: { ...move.to },
                    captured: capturedPiece,
                    enPassant: move.enPassant,
                    castle: move.castle,
                    castlingRights: JSON.parse(JSON.stringify(this.castlingRights)),
                    enPassantTarget: this.enPassantTarget,
                    halfMoveClock: this.halfMoveClock
                };
                
                // Обновляем счетчик полуходов
                if (capturedPiece || piece === '♙' || piece === '♟') {
                    this.halfMoveClock = 0;
                } else {
                    this.halfMoveClock++;
                }
                
                // Обновляем право на рокировку
                if (piece === '♔') {
                    this.castlingRights.white.kingside = false;
                    this.castlingRights.white.queenside = false;
                } else if (piece === '♚') {
                    this.castlingRights.black.kingside = false;
                    this.castlingRights.black.queenside = false;
                } else if (piece === '♖') {
                    if (move.from.row === 7 && move.from.col === 0) {
                        this.castlingRights.white.queenside = false;
                    } else if (move.from.row === 7 && move.from.col === 7) {
                        this.castlingRights.white.kingside = false;
                    }
                } else if (piece === '♜') {
                    if (move.from.row === 0 && move.from.col === 0) {
                        this.castlingRights.black.queenside = false;
                    } else if (move.from.row === 0 && move.from.col === 7) {
                        this.castlingRights.black.kingside = false;
                    }
                }
                
                // Выполняем ход
                this.board[move.to.row][move.to.col] = piece;
                this.board[move.from.row][move.from.col] = '';
                
                // Обработка взятия на проходе
                if (move.enPassant) {
                    const capturedRow = pieceColor === 'white' ? move.to.row + 1 : move.to.row - 1;
                    const capturedPieceEnPassant = this.board[capturedRow][move.to.col];
                    this.board[capturedRow][move.to.col] = '';
                    moveRecord.captured = capturedPieceEnPassant;
                }
                
                // Обработка рокировки
                if (move.castle) {
                    if (move.castle === 'kingside') {
                        if (pieceColor === 'white') {
                            this.board[7][5] = this.board[7][7];
                            this.board[7][7] = '';
                        } else {
                            this.board[0][5] = this.board[0][7];
                            this.board[0][7] = '';
                        }
                    } else if (move.castle === 'queenside') {
                        if (pieceColor === 'white') {
                            this.board[7][3] = this.board[7][0];
                            this.board[7][0] = '';
                        } else {
                            this.board[0][3] = this.board[0][0];
                            this.board[0][0] = '';
                        }
                    }
                }
                
                // Превращение пешки
                if ((piece === '♙' && move.to.row === 0) || (piece === '♟' && move.to.row === 7)) {
                    if (this.analysisMode) {
                        // В режиме анализа автоматически выбираем ферзя
                        this.board[move.to.row][move.to.col] = pieceColor === 'white' ? '♕' : '♛';
                    } else {
                        // TODO: Добавить диалог выбора фигуры
                        this.board[move.to.row][move.to.col] = pieceColor === 'white' ? '♕' : '♛';
                    }
                }
                
                // Обновляем цель для взятия на проходе
                if ((piece === '♙' && Math.abs(move.from.row - move.to.row) === 2) ||
                    (piece === '♟' && Math.abs(move.from.row - move.to.row) === 2)) {
                    this.enPassantTarget = {
                        row: (move.from.row + move.to.row) / 2,
                        col: move.from.col
                    };
                } else {
                    this.enPassantTarget = null;
                }
                
                // Добавляем в историю
                this.moveHistory.push(moveRecord);
                this.lastMove = move;
                
                // Добавляем съеденную фигуру
                if (capturedPiece) {
                    if (pieceColor === 'white') {
                        this.capturedPieces.black.push(capturedPiece);
                    } else {
                        this.capturedPieces.white.push(capturedPiece);
                    }
                }
                
                // Смена игрока
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                if (this.currentPlayer === 'white') {
                    this.fullMoveNumber++;
                }
                
                this.updateStatus();
                this.renderBoard();
                this.updateMovesList();
                this.updateCapturedPieces();
            }
            
            updateStatus() {
                const statusElement = document.getElementById('gameStatus');
                const isCheck = this.isKingInCheck(this.currentPlayer);
                
                if (this.isCheckmate(this.currentPlayer)) {
                    statusElement.textContent = `Мат! Победили ${this.currentPlayer === 'white' ? 'черные' : 'белые'}`;
                } else if (this.isStalemate(this.currentPlayer)) {
                    statusElement.textContent = 'Пат! Ничья';
                } else if (isCheck) {
                    statusElement.textContent = `Шах ${this.currentPlayer === 'white' ? 'белым' : 'черным'}`;
                } else {
                    statusElement.textContent = `Ход ${this.currentPlayer === 'white' ? 'белых' : 'черных'}`;
                }
            }
            
            isKingInCheck(color) {
                // Находим короля
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color) {
                            if (piece === '♔' || piece === '♚') {
                                return this.isSquareAttacked(row, col, color);
                            }
                        }
                    }
                }
                return false;
            }
            
            isCheckmate(color) {
                if (!this.isKingInCheck(color)) return false;
                
                // Проверяем, есть ли легальные ходы
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color) {
                            const moves = this.getValidMoves(row, col);
                            if (moves.length > 0) return false;
                        }
                    }
                }
                
                return true;
            }
            
            isStalemate(color) {
                if (this.isKingInCheck(color)) return false;
                
                // Проверяем, есть ли легальные ходы
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color) {
                            const moves = this.getValidMoves(row, col);
                            if (moves.length > 0) return false;
                        }
                    }
                }
                
                return true;
            }
            
            undoMove() {
                if (this.moveHistory.length === 0) return;
                
                const lastMove = this.moveHistory.pop();
                
                // Отменяем ход
                this.board[lastMove.from.row][lastMove.from.col] = lastMove.piece;
                this.board[lastMove.to.row][lastMove.to.col] = lastMove.captured || '';
                
                // Отменяем рокировку
                if (lastMove.castle) {
                    if (lastMove.castle === 'kingside') {
                        if (this.getPieceColor(lastMove.piece) === 'white') {
                            this.board[7][7] = '♖';
                            this.board[7][5] = '';
                        } else {
                            this.board[0][7] = '♜';
                            this.board[0][5] = '';
                        }
                    } else if (lastMove.castle === 'queenside') {
                        if (this.getPieceColor(lastMove.piece) === 'white') {
                            this.board[7][0] = '♖';
                            this.board[7][3] = '';
                        } else {
                            this.board[0][0] = '♜';
                            this.board[0][3] = '';
                        }
                    }
                }
                
                // Отменяем взятие на проходе
                if (lastMove.enPassant) {
                    const capturedRow = this.getPieceColor(lastMove.piece) === 'white' ? 
                                        lastMove.to.row + 1 : lastMove.to.row - 1;
                    this.board[capturedRow][lastMove.to.col] = 
                        this.getPieceColor(lastMove.piece) === 'white' ? '♟' : '♙';
                }
                
                // Восстанавливаем права на рокировку
                this.castlingRights = lastMove.castlingRights;
                this.enPassantTarget = lastMove.enPassantTarget;
                this.halfMoveClock = lastMove.halfMoveClock;
                
                // Убираем съеденную фигуру из списка
                if (lastMove.captured) {
                    const color = this.getPieceColor(lastMove.piece) === 'white' ? 'black' : 'white';
                    const index = this.capturedPieces[color].indexOf(lastMove.captured);
                    if (index > -1) {
                        this.capturedPieces[color].splice(index, 1);
                    }
                }
                
                // Смена игрока обратно
                this.currentPlayer = this.getPieceColor(lastMove.piece);
                if (this.currentPlayer === 'white') {
                    this.fullMoveNumber--;
                }
                
                this.lastMove = this.moveHistory[this.moveHistory.length - 1] || null;
                this.selectedSquare = null;
                this.possibleMoves = [];
                
                this.updateStatus();
                this.renderBoard();
                this.updateMovesList();
                this.updateCapturedPieces();
            }
            
            resetGame() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.lastMove = null;
                this.castlingRights = {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                };
                this.enPassantTarget = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                
                this.updateStatus();
                this.renderBoard();
                this.updateMovesList();
                this.updateCapturedPieces();
            }
            
            toggleAnalysis() {
                this.analysisMode = !this.analysisMode;
                const button = document.querySelector('button.analysis');
                if (button) {
                    button.style.background = this.analysisMode ? '#ff9800' : '#2196F3';
                }
            }
            
            flipBoard() {
                this.boardFlipped = !this.boardFlipped;
                this.renderBoard();
            }
            
            updateMovesList() {
                const movesList = document.getElementById('movesList');
                movesList.innerHTML = '';
                
                for (let i = 0; i < this.moveHistory.length; i += 2) {
                    const moveNumber = Math.floor(i / 2) + 1;
                    const moveDiv = document.createElement('div');
                    moveDiv.className = 'move-item';
                    
                    const whiteMove = this.moveHistory[i];
                    const blackMove = this.moveHistory[i + 1];
                    
                    moveDiv.innerHTML = `
                        <span class="notation">${moveNumber}.</span>
                        <span class="white">${this.formatMove(whiteMove)}</span>
                        ${blackMove ? `<span class="black">${this.formatMove(blackMove)}</span>` : ''}
                    `;
                    
                    moveDiv.addEventListener('click', () => this.goToMove(i + (blackMove ? 1 : 0)));
                    movesList.appendChild(moveDiv);
                }
            }
            
            formatMove(move) {
                const piece = move.piece;
                const fromCol = String.fromCharCode(97 + move.from.col);
                const fromRow = 8 - move.from.row;
                const toCol = String.fromCharCode(97 + move.to.col);
                const toRow = 8 - move.to.row;
                
                if (move.castle === 'kingside') return '0-0';
                if (move.castle === 'queenside') return '0-0-0';
                
                let notation = '';
                if (piece !== '♙' && piece !== '♟') {
                    const pieceSymbols = { '♔': 'K', '♕': 'Q', '♖': 'R', '♗': 'B', '♘': 'N' };
                    notation += pieceSymbols[piece] || '';
                }
                
                if (move.captured) notation += 'x';
                notation += toCol + toRow;
                
                return notation;
            }
            
            updateCapturedPieces() {
                const whiteCaptured = document.getElementById('capturedWhitePieces');
                const blackCaptured = document.getElementById('capturedBlackPieces');
                
                whiteCaptured.innerHTML = '<span style="color: #aaa;">Съеденные черные:</span> ' + 
                    this.capturedPieces.black.join(' ');
                blackCaptured.innerHTML = '<span style="color: #aaa;">Съеденные белые:</span> ' + 
                    this.capturedPieces.white.join(' ');
            }
            
            goToMove(moveIndex) {
                // TODO: Implement going to specific move
                console.log('Go to move', moveIndex);
            }
        }
        
        const chessGame = new ChessGame();
    </script>
</body>
</html>
